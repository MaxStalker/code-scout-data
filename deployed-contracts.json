[{"address":"0x329feb3ab062d289","contractName":"Andbox_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  Andbox_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  Andbox_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract Andbox_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of Andbox_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            Andbox_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            Andbox_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            Andbox_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            Andbox_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintAndbox_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintAndbox_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= Andbox_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create Andbox_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            Andbox_NFT.totalSupply = Andbox_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintAndbox_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintAndbox_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintAndbox_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            Andbox_NFT.totalSupply = Andbox_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                Andbox_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            Andbox_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                Andbox_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &Andbox_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit Andbox_NFT into their Collection. It also allows for reading\n    // the details of Andbox_NFT in the Collection.\n    pub resource interface Andbox_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowAndbox_NFT(id: UInt64): &Andbox_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow Andbox_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of Andbox_NFT NFTs owned by an account\n    //\n    pub resource Collection: Andbox_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @Andbox_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowAndbox_NFT\n        // Gets a reference to an NFT in the collection as a Andbox_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the Andbox_NFT.\n        //\n        pub fun borrowAndbox_NFT(id: UInt64): &Andbox_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &Andbox_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a Andbox_NFT from an account's Collection, if available.\n    // If an account does not have a Andbox_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &Andbox_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(Andbox_NFT.CollectionPublicPath)\n            .borrow<&Andbox_NFT.Collection{Andbox_NFT.Andbox_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust Andbox_NFT.Collection.borrowAndbox_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowAndbox_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [Andbox_NFT.SeriesData] {\n        return Andbox_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [Andbox_NFT.NFTSetData] {\n        return Andbox_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return Andbox_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return Andbox_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return Andbox_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return Andbox_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Andbox_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Andbox_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/Andbox_NFTCollection\n        self.CollectionPublicPath = /public/Andbox_NFTCollection\n        self.AdminStoragePath = /storage/Andbox_NFTAdmin\n        self.AdminPrivatePath = /private/Andbox_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&Andbox_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"Art_NFT","code":"\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract Art_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of Art_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            Art_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            Art_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            Art_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            Art_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintArt_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintArt_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= Art_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create Art_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            Art_NFT.totalSupply = Art_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintArt_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintArt_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintArt_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            Art_NFT.totalSupply = Art_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                Art_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            Art_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                Art_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &Art_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit Art_NFT into their Collection. It also allows for reading\n    // the details of Art_NFT in the Collection.\n    pub resource interface Art_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowArt_NFT(id: UInt64): &Art_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow Art_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of Art_NFT NFTs owned by an account\n    //\n    pub resource Collection: Art_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an UInt64 ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @Art_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowArt_NFT\n        // Gets a reference to an NFT in the collection as a Art_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the Art_NFT.\n        //\n        pub fun borrowArt_NFT(id: UInt64): &Art_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &Art_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a Art_NFT from an account's Collection, if available.\n    // If an account does not have a Art_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &Art_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(Art_NFT.CollectionPublicPath)\n            .borrow<&Art_NFT.Collection{Art_NFT.Art_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust Art_NFT.Collection.borrowArt_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowArt_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [Art_NFT.SeriesData] {\n        return Art_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [Art_NFT.NFTSetData] {\n        return Art_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return Art_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return Art_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return Art_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return Art_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Art_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Art_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/Art_NFTCollection\n        self.CollectionPublicPath = /public/Art_NFTCollection\n        self.AdminStoragePath = /storage/Art_NFTAdmin\n        self.AdminPrivatePath = /private/Art_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&Art_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"Atheletes_Unlimited_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  Atheletes_Unlimited_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  Atheletes_Unlimited_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract Atheletes_Unlimited_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of Atheletes_Unlimited_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            Atheletes_Unlimited_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            Atheletes_Unlimited_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            Atheletes_Unlimited_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            Atheletes_Unlimited_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintAtheletes_Unlimited_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintAtheletes_Unlimited_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= Atheletes_Unlimited_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create Atheletes_Unlimited_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            Atheletes_Unlimited_NFT.totalSupply = Atheletes_Unlimited_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintAtheletes_Unlimited_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintAtheletes_Unlimited_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintAtheletes_Unlimited_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            Atheletes_Unlimited_NFT.totalSupply = Atheletes_Unlimited_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                Atheletes_Unlimited_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            Atheletes_Unlimited_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                Atheletes_Unlimited_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &Atheletes_Unlimited_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit Atheletes_Unlimited_NFT into their Collection. It also allows for reading\n    // the details of Atheletes_Unlimited_NFT in the Collection.\n    pub resource interface Atheletes_Unlimited_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowAtheletes_Unlimited_NFT(id: UInt64): &Atheletes_Unlimited_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow Atheletes_Unlimited_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of Atheletes_Unlimited_NFT NFTs owned by an account\n    //\n    pub resource Collection: Atheletes_Unlimited_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @Atheletes_Unlimited_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowAtheletes_Unlimited_NFT\n        // Gets a reference to an NFT in the collection as a Atheletes_Unlimited_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the Atheletes_Unlimited_NFT.\n        //\n        pub fun borrowAtheletes_Unlimited_NFT(id: UInt64): &Atheletes_Unlimited_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &Atheletes_Unlimited_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a Atheletes_Unlimited_NFT from an account's Collection, if available.\n    // If an account does not have a Atheletes_Unlimited_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &Atheletes_Unlimited_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(Atheletes_Unlimited_NFT.CollectionPublicPath)\n            .borrow<&Atheletes_Unlimited_NFT.Collection{Atheletes_Unlimited_NFT.Atheletes_Unlimited_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust Atheletes_Unlimited_NFT.Collection.borrowAtheletes_Unlimited_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowAtheletes_Unlimited_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [Atheletes_Unlimited_NFT.SeriesData] {\n        return Atheletes_Unlimited_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [Atheletes_Unlimited_NFT.NFTSetData] {\n        return Atheletes_Unlimited_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return Atheletes_Unlimited_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return Atheletes_Unlimited_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return Atheletes_Unlimited_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return Atheletes_Unlimited_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Atheletes_Unlimited_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Atheletes_Unlimited_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/Atheletes_Unlimited_NFTCollection\n        self.CollectionPublicPath = /public/Atheletes_Unlimited_NFTCollection\n        self.AdminStoragePath = /storage/Atheletes_Unlimited_NFTAdmin\n        self.AdminPrivatePath = /private/Atheletes_Unlimited_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&Atheletes_Unlimited_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}"},{"address":"0x329feb3ab062d289","contractName":"BlockleteGames_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  BlockleteGames_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  BlockleteGames_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract BlockleteGames_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of BlockleteGames_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            BlockleteGames_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            BlockleteGames_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            BlockleteGames_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            BlockleteGames_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintBlockleteGames_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintBlockleteGames_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= BlockleteGames_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create BlockleteGames_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            BlockleteGames_NFT.totalSupply = BlockleteGames_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintBlockleteGames_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintBlockleteGames_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintBlockleteGames_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            BlockleteGames_NFT.totalSupply = BlockleteGames_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                BlockleteGames_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            BlockleteGames_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                BlockleteGames_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &BlockleteGames_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit BlockleteGames_NFT into their Collection. It also allows for reading\n    // the details of BlockleteGames_NFT in the Collection.\n    pub resource interface BlockleteGames_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowBlockleteGames_NFT(id: UInt64): &BlockleteGames_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow BlockleteGames_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of BlockleteGames_NFT NFTs owned by an account\n    //\n    pub resource Collection: BlockleteGames_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @BlockleteGames_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowBlockleteGames_NFT\n        // Gets a reference to an NFT in the collection as a BlockleteGames_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the BlockleteGames_NFT.\n        //\n        pub fun borrowBlockleteGames_NFT(id: UInt64): &BlockleteGames_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &BlockleteGames_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a BlockleteGames_NFT from an account's Collection, if available.\n    // If an account does not have a BlockleteGames_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &BlockleteGames_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(BlockleteGames_NFT.CollectionPublicPath)\n            .borrow<&BlockleteGames_NFT.Collection{BlockleteGames_NFT.BlockleteGames_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust BlockleteGames_NFT.Collection.borrowBlockleteGames_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowBlockleteGames_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [BlockleteGames_NFT.SeriesData] {\n        return BlockleteGames_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [BlockleteGames_NFT.NFTSetData] {\n        return BlockleteGames_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return BlockleteGames_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return BlockleteGames_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return BlockleteGames_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return BlockleteGames_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = BlockleteGames_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = BlockleteGames_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/BlockleteGames_NFTCollection\n        self.CollectionPublicPath = /public/BlockleteGames_NFTCollection\n        self.AdminStoragePath = /storage/BlockleteGames_NFTAdmin\n        self.AdminPrivatePath = /private/BlockleteGames_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&BlockleteGames_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"BreakingT_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  BreakingT_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  BreakingT_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract BreakingT_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of BreakingT_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            BreakingT_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            BreakingT_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            BreakingT_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            BreakingT_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintBreakingT_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintBreakingT_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= BreakingT_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create BreakingT_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            BreakingT_NFT.totalSupply = BreakingT_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintBreakingT_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintBreakingT_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintBreakingT_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            BreakingT_NFT.totalSupply = BreakingT_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                BreakingT_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            BreakingT_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                BreakingT_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &BreakingT_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit BreakingT_NFT into their Collection. It also allows for reading\n    // the details of BreakingT_NFT in the Collection.\n    pub resource interface BreakingT_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowBreakingT_NFT(id: UInt64): &BreakingT_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow BreakingT_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of BreakingT_NFT NFTs owned by an account\n    //\n    pub resource Collection: BreakingT_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @BreakingT_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowBreakingT_NFT\n        // Gets a reference to an NFT in the collection as a BreakingT_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the BreakingT_NFT.\n        //\n        pub fun borrowBreakingT_NFT(id: UInt64): &BreakingT_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &BreakingT_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a BreakingT_NFT from an account's Collection, if available.\n    // If an account does not have a BreakingT_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &BreakingT_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(BreakingT_NFT.CollectionPublicPath)\n            .borrow<&BreakingT_NFT.Collection{BreakingT_NFT.BreakingT_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust BreakingT_NFT.Collection.borrowBreakingT_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowBreakingT_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [BreakingT_NFT.SeriesData] {\n        return BreakingT_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [BreakingT_NFT.NFTSetData] {\n        return BreakingT_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return BreakingT_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return BreakingT_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return BreakingT_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return BreakingT_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = BreakingT_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = BreakingT_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/BreakingT_NFTCollection\n        self.CollectionPublicPath = /public/BreakingT_NFTCollection\n        self.AdminStoragePath = /storage/BreakingT_NFTAdmin\n        self.AdminPrivatePath = /private/BreakingT_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&BreakingT_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"CNN_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  CNN_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  CNN_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract CNN_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of CNN_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            CNN_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            CNN_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            CNN_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            CNN_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintCNN_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintCNN_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= CNN_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create CNN_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            CNN_NFT.totalSupply = CNN_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintCNN_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintCNN_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintCNN_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            CNN_NFT.totalSupply = CNN_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                CNN_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            CNN_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                CNN_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &CNN_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit CNN_NFT into their Collection. It also allows for reading\n    // the details of CNN_NFT in the Collection.\n    pub resource interface CNN_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowCNN_NFT(id: UInt64): &CNN_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow CNN_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of CNN_NFT NFTs owned by an account\n    //\n    pub resource Collection: CNN_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @CNN_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowCNN_NFT\n        // Gets a reference to an NFT in the collection as a CNN_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the CNN_NFT.\n        //\n        pub fun borrowCNN_NFT(id: UInt64): &CNN_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &CNN_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a CNN_NFT from an account's Collection, if available.\n    // If an account does not have a CNN_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &CNN_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(CNN_NFT.CollectionPublicPath)\n            .borrow<&CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust CNN_NFT.Collection.borrowCNN_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowCNN_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [CNN_NFT.SeriesData] {\n        return CNN_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [CNN_NFT.NFTSetData] {\n        return CNN_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return CNN_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return CNN_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return CNN_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return CNN_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = CNN_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = CNN_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/CNN_NFTCollection\n        self.CollectionPublicPath = /public/CNN_NFTCollection\n        self.AdminStoragePath = /storage/CNN_NFTAdmin\n        self.AdminPrivatePath = /private/CNN_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&CNN_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}"},{"address":"0x329feb3ab062d289","contractName":"Canes_Vault_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  Canes_Vault_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  Canes_Vault_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract Canes_Vault_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of Canes_Vault_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            Canes_Vault_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            Canes_Vault_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            Canes_Vault_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            Canes_Vault_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintCanes_Vault_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintCanes_Vault_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= Canes_Vault_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create Canes_Vault_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            Canes_Vault_NFT.totalSupply = Canes_Vault_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintCanes_Vault_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintCanes_Vault_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintCanes_Vault_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            Canes_Vault_NFT.totalSupply = Canes_Vault_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                Canes_Vault_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            Canes_Vault_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                Canes_Vault_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &Canes_Vault_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit Canes_Vault_NFT into their Collection. It also allows for reading\n    // the details of Canes_Vault_NFT in the Collection.\n    pub resource interface Canes_Vault_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowCanes_Vault_NFT(id: UInt64): &Canes_Vault_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow Canes_Vault_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of Canes_Vault_NFT NFTs owned by an account\n    //\n    pub resource Collection: Canes_Vault_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @Canes_Vault_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowCanes_Vault_NFT\n        // Gets a reference to an NFT in the collection as a Canes_Vault_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the Canes_Vault_NFT.\n        //\n        pub fun borrowCanes_Vault_NFT(id: UInt64): &Canes_Vault_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &Canes_Vault_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a Canes_Vault_NFT from an account's Collection, if available.\n    // If an account does not have a Canes_Vault_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &Canes_Vault_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(Canes_Vault_NFT.CollectionPublicPath)\n            .borrow<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust Canes_Vault_NFT.Collection.borrowCanes_Vault_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowCanes_Vault_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [Canes_Vault_NFT.SeriesData] {\n        return Canes_Vault_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [Canes_Vault_NFT.NFTSetData] {\n        return Canes_Vault_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return Canes_Vault_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return Canes_Vault_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return Canes_Vault_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return Canes_Vault_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Canes_Vault_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = Canes_Vault_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/Canes_Vault_NFTCollection\n        self.CollectionPublicPath = /public/Canes_Vault_NFTCollection\n        self.AdminStoragePath = /storage/Canes_Vault_NFTAdmin\n        self.AdminPrivatePath = /private/Canes_Vault_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&Canes_Vault_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"GL_BridgeTest_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  GL_BridgeTest_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  GL_BridgeTest_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract GL_BridgeTest_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of GL_BridgeTest_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            GL_BridgeTest_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            GL_BridgeTest_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            GL_BridgeTest_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            GL_BridgeTest_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintGL_BridgeTest_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintGL_BridgeTest_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= GL_BridgeTest_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create GL_BridgeTest_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            GL_BridgeTest_NFT.totalSupply = GL_BridgeTest_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintGL_BridgeTest_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintGL_BridgeTest_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintGL_BridgeTest_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            GL_BridgeTest_NFT.totalSupply = GL_BridgeTest_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                GL_BridgeTest_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            GL_BridgeTest_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                GL_BridgeTest_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &GL_BridgeTest_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit GL_BridgeTest_NFT into their Collection. It also allows for reading\n    // the details of GL_BridgeTest_NFT in the Collection.\n    pub resource interface GL_BridgeTest_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowGL_BridgeTest_NFT(id: UInt64): &GL_BridgeTest_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow GL_BridgeTest_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of GL_BridgeTest_NFT NFTs owned by an account\n    //\n    pub resource Collection: GL_BridgeTest_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @GL_BridgeTest_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowGL_BridgeTest_NFT\n        // Gets a reference to an NFT in the collection as a GL_BridgeTest_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the GL_BridgeTest_NFT.\n        //\n        pub fun borrowGL_BridgeTest_NFT(id: UInt64): &GL_BridgeTest_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &GL_BridgeTest_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a GL_BridgeTest_NFT from an account's Collection, if available.\n    // If an account does not have a GL_BridgeTest_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &GL_BridgeTest_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(GL_BridgeTest_NFT.CollectionPublicPath)\n            .borrow<&GL_BridgeTest_NFT.Collection{GL_BridgeTest_NFT.GL_BridgeTest_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust GL_BridgeTest_NFT.Collection.borrowGL_BridgeTest_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowGL_BridgeTest_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [GL_BridgeTest_NFT.SeriesData] {\n        return GL_BridgeTest_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [GL_BridgeTest_NFT.NFTSetData] {\n        return GL_BridgeTest_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return GL_BridgeTest_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return GL_BridgeTest_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return GL_BridgeTest_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return GL_BridgeTest_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = GL_BridgeTest_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = GL_BridgeTest_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/GL_BridgeTest_NFTCollection\n        self.CollectionPublicPath = /public/GL_BridgeTest_NFTCollection\n        self.AdminStoragePath = /storage/GL_BridgeTest_NFTAdmin\n        self.AdminPrivatePath = /private/GL_BridgeTest_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&GL_BridgeTest_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"RaceDay_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  RaceDay_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  RaceDay_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract RaceDay_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of RaceDay_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            RaceDay_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            RaceDay_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            RaceDay_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            RaceDay_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintRaceDay_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintRaceDay_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= RaceDay_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create RaceDay_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            RaceDay_NFT.totalSupply = RaceDay_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintRaceDay_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintRaceDay_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintRaceDay_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            RaceDay_NFT.totalSupply = RaceDay_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                RaceDay_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            RaceDay_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                RaceDay_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &RaceDay_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit RaceDay_NFT into their Collection. It also allows for reading\n    // the details of RaceDay_NFT in the Collection.\n    pub resource interface RaceDay_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowRaceDay_NFT(id: UInt64): &RaceDay_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow RaceDay_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of RaceDay_NFT NFTs owned by an account\n    //\n    pub resource Collection: RaceDay_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @RaceDay_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowRaceDay_NFT\n        // Gets a reference to an NFT in the collection as a RaceDay_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the RaceDay_NFT.\n        //\n        pub fun borrowRaceDay_NFT(id: UInt64): &RaceDay_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &RaceDay_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a RaceDay_NFT from an account's Collection, if available.\n    // If an account does not have a RaceDay_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &RaceDay_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(RaceDay_NFT.CollectionPublicPath)\n            .borrow<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust RaceDay_NFT.Collection.borrowRaceDay_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowRaceDay_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [RaceDay_NFT.SeriesData] {\n        return RaceDay_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [RaceDay_NFT.NFTSetData] {\n        return RaceDay_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return RaceDay_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return RaceDay_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return RaceDay_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return RaceDay_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = RaceDay_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = RaceDay_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/RaceDay_NFTCollection\n        self.CollectionPublicPath = /public/RaceDay_NFTCollection\n        self.AdminStoragePath = /storage/RaceDay_NFTAdmin\n        self.AdminPrivatePath = /private/RaceDay_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&RaceDay_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"RareRooms_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  RareRooms_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  RareRooms_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract RareRooms_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of RareRooms_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            RareRooms_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            RareRooms_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            RareRooms_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            RareRooms_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintRareRooms_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintRareRooms_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= RareRooms_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create RareRooms_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            RareRooms_NFT.totalSupply = RareRooms_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintRareRooms_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintRareRooms_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintRareRooms_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            RareRooms_NFT.totalSupply = RareRooms_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                RareRooms_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            RareRooms_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                RareRooms_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &RareRooms_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit RareRooms_NFT into their Collection. It also allows for reading\n    // the details of RareRooms_NFT in the Collection.\n    pub resource interface RareRooms_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowRareRooms_NFT(id: UInt64): &RareRooms_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow RareRooms_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of RareRooms_NFT NFTs owned by an account\n    //\n    pub resource Collection: RareRooms_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @RareRooms_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowRareRooms_NFT\n        // Gets a reference to an NFT in the collection as a RareRooms_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the RareRooms_NFT.\n        //\n        pub fun borrowRareRooms_NFT(id: UInt64): &RareRooms_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &RareRooms_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a RareRooms_NFT from an account's Collection, if available.\n    // If an account does not have a RareRooms_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &RareRooms_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(RareRooms_NFT.CollectionPublicPath)\n            .borrow<&RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust RareRooms_NFT.Collection.borrowRareRooms_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowRareRooms_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [RareRooms_NFT.SeriesData] {\n        return RareRooms_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [RareRooms_NFT.NFTSetData] {\n        return RareRooms_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return RareRooms_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return RareRooms_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return RareRooms_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return RareRooms_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = RareRooms_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = RareRooms_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/RareRooms_NFTCollection\n        self.CollectionPublicPath = /public/RareRooms_NFTCollection\n        self.AdminStoragePath = /storage/RareRooms_NFTAdmin\n        self.AdminPrivatePath = /private/RareRooms_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&RareRooms_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0x329feb3ab062d289","contractName":"The_Next_Cartel_NFT","code":"/////////////////////////////////////////////////////////////////////\n//\n//  The_Next_Cartel_NFT.cdc\n//\n//  This smart contract has the core NFT functionality for \n//  The_Next_Cartel_NFTs. It is part of the NFT Bridge platform\n//  created by GigLabs.\n//  \n//  Author: Brian Burns brian@giglabs.io\n//\n/////////////////////////////////////////////////////////////////////\n\nimport NonFungibleToken from 0x1d7e57aa55817448\n\npub contract The_Next_Cartel_NFT: NonFungibleToken {\n\n    // Events\n    //\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Minted(id: UInt64)\n    pub event NFTDestroyed(id: UInt64)\n    pub event SeriesCreated(seriesId: UInt32)\n    pub event SeriesSealed(seriesId: UInt32)\n    pub event SetCreated(seriesId: UInt32, setId: UInt32)\n    pub event SeriesMetadataUpdated(seriesId: UInt32)\n    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n    pub let AdminStoragePath: StoragePath\n    pub let AdminPrivatePath: PrivatePath\n\n    // totalSupply\n    // The total number of The_Next_Cartel_NFT that have been minted\n    //\n    pub var totalSupply: UInt64\n\n    // Variable size dictionary of SetData structs\n    access(self) var setData: {UInt32: NFTSetData}\n\n    // Variable size dictionary of SeriesData structs\n    access(self) var seriesData: {UInt32: SeriesData}\n\n    // Variable size dictionary of Series resources\n    access(self) var series: @{UInt32: Series}\n\n\n    pub struct NFTSetData {\n\n        // Unique ID for the Set\n        pub let setId: UInt32\n\n        // Series ID the Set belongs to\n        pub let seriesId: UInt32\n\n        // Maximum number of editions that can be minted in this Set\n        pub let maxEditions: UInt32\n                  \n        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.\n        // This is an optional dictionary of IPFS hashes, which will allow marketplaces\n        // to pull the metadata for each NFT edition\n        access(self) var ipfsMetadataHashes: {UInt32: String}\n\n        // Set level metadata\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n        \n        init(\n            setId: UInt32,\n            seriesId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n\n            self.setId = setId\n            self.seriesId = seriesId\n            self.maxEditions = maxEditions\n            self.metadata = metadata\n            self.ipfsMetadataHashes = ipfsMetadataHashes\n\n            emit SetCreated(seriesId: self.seriesId, setId: self.setId)\n        }\n\n        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {\n            return self.ipfsMetadataHashes[editionNum]\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n\n        pub fun getMetadataField(field: String): String? {\n            return self.metadata[field]\n        }\n    }\n\n    pub struct SeriesData {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Dictionary of metadata key value pairs\n        access(self) var metadata: {String: String}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n            self.seriesId = seriesId\n            self.metadata = metadata\n\n            emit SeriesCreated(seriesId: self.seriesId)\n        }\n\n        pub fun getMetadata(): {String: String} {\n            return self.metadata\n        }\n    }\n\n\n    // NFTSet\n    // Resource that allows an admin to mint new NFTs\n    //\n\tpub resource Series {\n\n        // Unique ID for the Series\n        pub let seriesId: UInt32\n\n        // Array of NFTSets that belong to this Series\n        access(self) var setIds: [UInt32]\n\n        // Series sealed state\n        pub var seriesSealedState: Bool;\n\n        // Set sealed state\n        access(self) var setSealedState: {UInt32: Bool};\n\n        // Current number of editions minted per Set\n        access(self) var numberEditionsMintedPerSet: {UInt32: UInt32}\n\n        init(\n            seriesId: UInt32,\n            metadata: {String: String}) {\n\n            self.seriesId = seriesId\n            self.seriesSealedState = false\n            self.numberEditionsMintedPerSet = {}\n            self.setIds = []\n            self.setSealedState = {}\n\n            The_Next_Cartel_NFT.seriesData[seriesId] = SeriesData(\n                    seriesId: seriesId,\n                    metadata: metadata\n            )      \n        }\n\n        pub fun addNftSet(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.setIds.contains(setId) == false: \"The Set has already been added to the Series.\"\n            }\n\n            // Create the new Set struct\n            var newNFTSet = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n\n            // Add the NFTSet to the array of Sets\n            self.setIds.append(setId)\n\n            // Initialize the NFT edition count to zero\n            self.numberEditionsMintedPerSet[setId] = 0\n\n            // Store it in the sets mapping field\n            The_Next_Cartel_NFT.setData[setId] = newNFTSet\n\n            emit SetCreated(seriesId: self.seriesId, setId: setId)\n        }\n\n        // updateSeriesMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Series creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Series metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSeriesMetadata(metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n            }\n            let newSeriesMetadata = SeriesData(\n                    seriesId: self.seriesId,\n                    metadata: metadata\n            )  \n            // Store updated Series in the Series mapping field\n            The_Next_Cartel_NFT.seriesData[self.seriesId] = newSeriesMetadata\n\n            emit SeriesMetadataUpdated(seriesId: self.seriesId)\n        }\n\n        // updateSetMetadata\n        // For practical reasons, a short period of time is given to update metadata\n        // following Set creation or minting of the NFT editions. Once the Series is\n        // sealed, no updates to the Set metadata will be possible - the information\n        // is permanent and immutable.\n        pub fun updateSetMetadata(\n            setId: UInt32,\n            maxEditions: UInt32,\n            ipfsMetadataHashes: {UInt32: String},\n            metadata: {String: String}) {\n            pre {\n                self.seriesSealedState == false:\n                    \"The Series is permanently sealed. No metadata updates can be made.\"\n                self.setIds.contains(setId) == true: \"The Set is not part of this Series.\"\n            }\n            let newSetMetadata = NFTSetData(\n                setId: setId,\n                seriesId: self.seriesId,\n                maxEditions: maxEditions,\n                ipfsMetadataHashes: ipfsMetadataHashes,\n                metadata: metadata\n            )\n            // Store updated Set in the Sets mapping field\n            The_Next_Cartel_NFT.setData[setId] = newSetMetadata\n\n            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)\n        }\n\n\t\t// mintThe_Next_Cartel_NFT\n        // Mints a new NFT with a new ID\n\t\t// and deposits it in the recipients collection using their collection reference\n        //\n\t    pub fun mintThe_Next_Cartel_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            tokenId: UInt64,\n            setId: UInt32) {\n            \n            pre {\n                self.numberEditionsMintedPerSet[setId] != nil: \"The Set does not exist.\"\n                self.numberEditionsMintedPerSet[setId]! <= The_Next_Cartel_NFT.getSetMaxEditions(setId: setId)!:\n                    \"Set has reached maximum NFT edition capacity.\"\n            }\n\n            // Gets the number of editions that have been minted so far in \n            // this set\n            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)\n\n\t\t\t// deposit it in the recipient's account using their reference\n\t\t\trecipient.deposit(token: <-create The_Next_Cartel_NFT.NFT(\n                tokenId: tokenId,\n                setId: setId,\n                editionNum: editionNum\n            ))\n\n            // Increment the count of global NFTs \n            The_Next_Cartel_NFT.totalSupply = The_Next_Cartel_NFT.totalSupply + (1 as UInt64)\n\n            // Update the count of Editions minted in the set\n            self.numberEditionsMintedPerSet[setId] = editionNum\n        }\n\n        // batchMintThe_Next_Cartel_NFT\n        // Mints multiple new NFTs given and deposits the NFTs\n        // into the recipients collection using their collection reference\n\t\tpub fun batchMintThe_Next_Cartel_NFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            setId: UInt32,\n            tokenIds: [UInt64]) {\n\n            pre {\n                tokenIds.length > 0:\n                    \"Number of token Ids must be > 0\"\n            }\n\n            for tokenId in tokenIds {\n                self.mintThe_Next_Cartel_NFT(\n                    recipient: recipient,\n                    tokenId: tokenId,\n                    setId: setId\n                )\n            }\n\t\t}\n\n        // sealSeries\n        // Once a series is sealed, the metadata for the NFTs in the Series can no\n        // longer be updated\n        //\n        pub fun sealSeries() {\n            pre {\n                self.seriesSealedState == false: \"The Series is already sealed\"\n            }\n            self.seriesSealedState = true\n\n            emit SeriesSealed(seriesId: self.seriesId)\n        }\n\t}\n\n    // NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        // The token's ID\n        pub let id: UInt64\n\n        // The Set id references this NFT belongs to\n        pub let setId: UInt32\n\n        // The specific edition number for this NFT\n        pub let editionNum: UInt32\n\n        // initializer\n        //\n        init(\n          tokenId: UInt64,\n          setId: UInt32,\n          editionNum: UInt32) {\n\n            self.id = tokenId\n            self.setId = setId\n            self.editionNum = editionNum\n\n            emit Minted(id: self.id)\n        }\n\n        // If the NFT is destroyed, emit an event\n        destroy() {\n            The_Next_Cartel_NFT.totalSupply = The_Next_Cartel_NFT.totalSupply - (1 as UInt64)\n            emit NFTDestroyed(id: self.id)\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important NFT \n    // functions\n    //\n    pub resource Admin {\n\n        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {\n            pre {\n                The_Next_Cartel_NFT.series[seriesId] == nil:\n                    \"Cannot add Series: The Series already exists\"\n            }\n\n            // Create the new Series\n            var newSeries <- create Series(\n                seriesId: seriesId,\n                metadata: metadata\n            )\n\n            // Add the new Series resource to the Series dictionary in the contract\n            The_Next_Cartel_NFT.series[seriesId] <-! newSeries\n        }\n\n        pub fun borrowSeries(seriesId: UInt32): &Series  {\n            pre {\n                The_Next_Cartel_NFT.series[seriesId] != nil:\n                    \"Cannot borrow Series: The Series does not exist\"\n            }\n\n            // Get a reference to the Series and return it\n            return &The_Next_Cartel_NFT.series[seriesId] as &Series\n        }\n\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n    }\n\n    // This is the interface that users can cast their NFT Collection as\n    // to allow others to deposit The_Next_Cartel_NFT into their Collection. It also allows for reading\n    // the details of The_Next_Cartel_NFT in the Collection.\n    pub resource interface The_Next_Cartel_NFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowThe_Next_Cartel_NFT(id: UInt64): &The_Next_Cartel_NFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow The_Next_Cartel_NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // Collection\n    // A collection of The_Next_Cartel_NFT NFTs owned by an account\n    //\n    pub resource Collection: The_Next_Cartel_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an `UInt64` ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw\n        // Removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple NFTs and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens\n        //\n\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit\n        // Takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @The_Next_Cartel_NFT.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs\n        // Returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT\n        // Gets a reference to an NFT in the collection\n        // so that the caller can read its metadata and call its methods\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // borrowThe_Next_Cartel_NFT\n        // Gets a reference to an NFT in the collection as a The_Next_Cartel_NFT,\n        // exposing all of its fields.\n        // This is safe as there are no functions that can be called on the The_Next_Cartel_NFT.\n        //\n        pub fun borrowThe_Next_Cartel_NFT(id: UInt64): &The_Next_Cartel_NFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n                return ref as! &The_Next_Cartel_NFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // destructor\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // initializer\n        //\n        init () {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // createEmptyCollection\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    // fetch\n    // Get a reference to a The_Next_Cartel_NFT from an account's Collection, if available.\n    // If an account does not have a The_Next_Cartel_NFT.Collection, panic.\n    // If it has a collection but does not contain the Id, return nil.\n    // If it has a collection and that collection contains the Id, return a reference to that.\n    //\n    pub fun fetch(_ from: Address, id: UInt64): &The_Next_Cartel_NFT.NFT? {\n        let collection = getAccount(from)\n            .getCapability(The_Next_Cartel_NFT.CollectionPublicPath)\n            .borrow<&The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}>()\n            ?? panic(\"Couldn't get collection\")\n        // We trust The_Next_Cartel_NFT.Collection.borrowThe_Next_Cartel_NFT to get the correct id\n        // (it checks it before returning it).\n        return collection.borrowThe_Next_Cartel_NFT(id: id)\n    }\n\n    // getAllSeries returns all the sets\n    //\n    // Returns: An array of all the series that have been created\n    pub fun getAllSeries(): [The_Next_Cartel_NFT.SeriesData] {\n        return The_Next_Cartel_NFT.seriesData.values\n    }\n\n    // getAllSets returns all the sets\n    //\n    // Returns: An array of all the sets that have been created\n    pub fun getAllSets(): [The_Next_Cartel_NFT.NFTSetData] {\n        return The_Next_Cartel_NFT.setData.values\n    }\n\n    // getSeriesMetadata returns the metadata that the specified Series\n    //            is associated with.\n    // \n    // Parameters: seriesId: The id of the Series that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {\n        return The_Next_Cartel_NFT.seriesData[seriesId]?.getMetadata()\n    }\n\n    // getSetMaxEditions returns the the maximum number of NFT editions that can\n    //        be minted in this Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The max number of NFT editions in this Set\n    pub fun getSetMaxEditions(setId: UInt32): UInt32? {\n        return The_Next_Cartel_NFT.setData[setId]?.maxEditions\n    }\n\n    // getSetMetadata returns all the metadata associated with a specific Set\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The metadata as a String to String mapping optional\n    pub fun getSetMetadata(setId: UInt32): {String: String}? {\n        return The_Next_Cartel_NFT.setData[setId]?.getMetadata()\n    }\n\n    // getSetSeriesId returns the Series Id the Set belongs to\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The Series Id\n    pub fun getSetSeriesId(setId: UInt32): UInt32? {\n        return The_Next_Cartel_NFT.setData[setId]?.seriesId\n    }\n\n    // getSetMetadata returns all the ipfs hashes for each nft \n    //     edition in the Set.\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //\n    // Returns: The ipfs hashes of nft editions as a Array of Strings\n    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = The_Next_Cartel_NFT.setData[setId] {\n            return set.getIpfsMetadataHash(editionNum: editionNum)\n        } else {\n            return nil\n        }\n    }\n\n    // getSetMetadataByField returns the metadata associated with a \n    //                        specific field of the metadata\n    // \n    // Parameters: setId: The id of the Set that is being searched\n    //             field: The field to search for\n    //\n    // Returns: The metadata field as a String Optional\n    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {\n        // Don't force a revert if the setId or field is invalid\n        if let set = The_Next_Cartel_NFT.setData[setId] {\n            return set.getMetadataField(field: field)\n        } else {\n            return nil\n        }\n    }\n\n    // initializer\n    //\n\tinit() {\n        // Set named paths\n        self.CollectionStoragePath = /storage/The_Next_Cartel_NFTCollection\n        self.CollectionPublicPath = /public/The_Next_Cartel_NFTCollection\n        self.AdminStoragePath = /storage/The_Next_Cartel_NFTAdmin\n        self.AdminPrivatePath = /private/The_Next_Cartel_NFTAdminUpgrade\n\n        // Initialize the total supply\n        self.totalSupply = 0\n\n        self.setData = {}\n        self.seriesData = {}\n        self.series <- {}\n\n        // Put Admin in storage\n        self.account.save(<-create Admin(), to: self.AdminStoragePath)\n\n        self.account.link<&The_Next_Cartel_NFT.Admin>(\n            self.AdminPrivatePath,\n            target: self.AdminStoragePath\n        ) ?? panic(\"Could not get a capability to the admin\")\n\n        emit ContractInitialized()\n\t}\n}\n"},{"address":"0xd796ff17107bbff6","contractName":"Art","code":"import NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Content from 0xd796ff17107bbff6\n\n/// A NFT contract to store art\npub contract Art: NonFungibleToken {\n\n\tpub let CollectionStoragePath: StoragePath\n\tpub let CollectionPublicPath: PublicPath\n\n\tpub var totalSupply: UInt64\n\n\tpub event ContractInitialized()\n\tpub event Withdraw(id: UInt64, from: Address?)\n\tpub event Deposit(id: UInt64, to: Address?)\n\tpub event Created(id: UInt64, metadata: Metadata)\n\tpub event Editioned(id: UInt64, from: UInt64, edition: UInt64, maxEdition: UInt64)\n\n\t//The public interface can show metadata and the content for the Art piece\n\tpub resource interface Public {\n\t\tpub let id: UInt64\n\t\tpub let metadata: Metadata\n\n\t\t//these three are added because I think they will be in the standard. Atleast dieter thinks it will be needed\n\t\tpub let name: String\n\t\tpub let description: String\n\t\tpub let schema: String? \n\n\t\tpub fun content() : String?\n\n\t\taccess(account) let royalty: {String: Royalty}\n\t\tpub fun cacheKey() : String\n\n\t}\n\n\tpub struct Metadata {\n\t\tpub let name: String\n\t\tpub let artist: String\n\t\tpub let artistAddress:Address\n\t\tpub let description: String\n\t\tpub let type: String\n\t\tpub let edition: UInt64\n\t\tpub let maxEdition: UInt64\n\n\n\t\tinit(name: String, \n\t\tartist: String,\n\t\tartistAddress:Address, \n\t\tdescription: String, \n\t\ttype: String, \n\t\tedition: UInt64,\n\t\tmaxEdition: UInt64) {\n\t\t\tself.name=name\n\t\t\tself.artist=artist\n\t\t\tself.artistAddress=artistAddress\n\t\t\tself.description=description\n\t\t\tself.type=type\n\t\t\tself.edition=edition\n\t\t\tself.maxEdition=maxEdition\n\t\t}\n\n\t}\n\n\tpub struct Royalty{\n\t\tpub let wallet:Capability<&{FungibleToken.Receiver}> \n\t\tpub let cut: UFix64\n\n\t\t/// @param wallet : The wallet to send royalty too\n\t\tinit(wallet:Capability<&{FungibleToken.Receiver}>, cut: UFix64 ){\n\t\t\tself.wallet=wallet\n\t\t\tself.cut=cut\n\t\t}\n\t}\n\n\tpub resource NFT: NonFungibleToken.INFT, Public {\n\t\t//TODO: tighten up the permission here.\n\t\tpub let id: UInt64\n\t\tpub let name: String\n\t\tpub let description: String\n\n\t\tpub let schema: String?\n\t\t//content can either be embedded in the NFT as and URL or a pointer to a Content collection to be stored onChain\n\t\t//a pointer will be used for all editions of the same Art when it is editioned \n\t\tpub let contentCapability:Capability<&Content.Collection>?\n\t\tpub let contentId: UInt64?\n\t\tpub let url: String?\n\t\tpub let metadata: Metadata\n\t\taccess(account) let royalty: {String: Royalty}\n\n\t\tinit(initID: UInt64, \n\t\tmetadata: Metadata,\n\t\tcontentCapability:Capability<&Content.Collection>?, \n\t\tcontentId: UInt64?, \n\t\turl: String?,\n\t\troyalty:{String: Royalty}) {\n\n\t\t\tself.id = initID\n\t\t\tself.metadata=metadata\n\t\t\tself.contentCapability=contentCapability\n\t\t\tself.contentId=contentId\n\t\t\tself.url=url\n\t\t\tself.royalty=royalty\n\t\t\tself.schema=nil\n\t\t\tself.name = metadata.name\n\t\t\tself.description=metadata.description\n\t\t}\n\n\t\tpub fun cacheKey() : String {\n\t\t\tif self.url != nil {\n\t\t\t\treturn self.url!\n\t\t\t}\n\t\t\treturn self.contentId!.toString()\n\t\t}\n\n\t\t//return the content for this NFT\n\t\tpub fun content() : String {\n\t\t\tif self.url != nil {\n\t\t\t\treturn self.url!\n\t\t\t}\n\n\t\t\tlet contentCollection= self.contentCapability!.borrow()!\n\t\t\treturn contentCollection.content(self.contentId!)\n\t\t}\n\t}\n\n\n\t//Standard NFT collectionPublic interface that can also borrowArt as the correct type\n\tpub resource interface CollectionPublic {\n\n\t\tpub fun deposit(token: @NonFungibleToken.NFT)\n\t\tpub fun getIDs(): [UInt64]\n\t\tpub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n\t\tpub fun borrowArt(id: UInt64): &{Art.Public}?\n\t}\n\n\n\tpub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n\t\t// dictionary of NFT conforming tokens\n\t\t// NFT is a resource type with an `UInt64` ID field\n\t\tpub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n\t\tinit () {\n\t\t\tself.ownedNFTs <- {}\n\t\t}\n\n\t\t// withdraw removes an NFT from the collection and moves it to the caller\n\t\tpub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\t\t\tlet token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n\t\t\temit Withdraw(id: token.id, from: self.owner?.address)\n\n\t\t\treturn <-token\n\t\t}\n\n\t\t// deposit takes a NFT and adds it to the collections dictionary\n\t\t// and adds the ID to the id array\n\t\tpub fun deposit(token: @NonFungibleToken.NFT) {\n\t\t\tlet token <- token as! @Art.NFT\n\n\t\t\tlet id: UInt64 = token.id\n\n\t\t\t// add the new token to the dictionary which removes the old one\n\t\t\tlet oldToken <- self.ownedNFTs[id] <- token\n\n\t\t\temit Deposit(id: id, to: self.owner?.address)\n\n\t\t\tdestroy oldToken\n\t\t}\n\n\t\t// getIDs returns an array of the IDs that are in the collection\n\t\tpub fun getIDs(): [UInt64] {\n\t\t\treturn self.ownedNFTs.keys\n\t\t}\n\n\t\t// borrowNFT gets a reference to an NFT in the collection\n\t\t// so that the caller can read its metadata and call its methods\n\t\tpub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n\t\t\treturn &self.ownedNFTs[id] as &NonFungibleToken.NFT\n\t\t}\n\n\t\t// borrowArt returns a borrowed reference to a Art \n\t\t// so that the caller can read data and call methods from it.\n\t\t//\n\t\t// Parameters: id: The ID of the NFT to get the reference for\n\t\t//\n\t\t// Returns: A reference to the NFT\n\t\tpub fun borrowArt(id: UInt64): &{Art.Public}? {\n\t\t\tif self.ownedNFTs[id] != nil {\n\t\t\t\tlet ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT\n\t\t\t\treturn ref as! &Art.NFT\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\n\t\tdestroy() {\n\t\t\tdestroy self.ownedNFTs\n\t\t}\n\t}\n\n\t// public function that anyone can call to create a new empty collection\n\tpub fun createEmptyCollection(): @NonFungibleToken.Collection {\n\t\treturn <- create Collection()\n\t}\n\n\n\n\tpub struct ArtData {\n\t\tpub let metadata: Art.Metadata\n\t\tpub let id: UInt64\n\t\tpub let cacheKey: String\n\t\tinit(metadata: Art.Metadata, id: UInt64, cacheKey: String) {\n\t\t\tself.metadata= metadata\n\t\t\tself.id=id\n\t\t\tself.cacheKey=cacheKey\n\t\t}\n\t}\n\n\n\n\tpub fun getContentForArt(address:Address, artId:UInt64) : String? {\n\n\t\tlet account=getAccount(address)\n\t\tif let artCollection= account.getCapability(self.CollectionPublicPath).borrow<&{Art.CollectionPublic}>()  {\n\t\t\treturn artCollection.borrowArt(id: artId)!.content()\n\t\t}\n\t\treturn nil\n\t}\n\n\t// We cannot return the content here since it will be too big to run in a script\n\tpub fun getArt(address:Address) : [ArtData] {\n\n\t\tvar artData: [ArtData] = []\n\t\tlet account=getAccount(address)\n\n\t\tif let artCollection= account.getCapability(self.CollectionPublicPath).borrow<&{Art.CollectionPublic}>()  {\n\t\t\tfor id in artCollection.getIDs() {\n\t\t\t\tvar art=artCollection.borrowArt(id: id) \n\t\t\t\tartData.append(ArtData(\n\t\t\t\t\tmetadata: art!.metadata,\n\t\t\t\t\tid: id, \n\t\t\t\t\tcacheKey: art!.cacheKey()))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn artData\n\t\t} \n\n\t\t//This method can only be called from another contract in the same account. In Versus case it is called from the VersusAdmin that is used to administer the solution\n\t\taccess(account) fun createArtWithContent(name: String, artist:String, artistAddress:Address, description: String, url: String, type: String, royalty: {String: Royalty}, edition: UInt64, maxEdition: UInt64) : @Art.NFT {\n\t\t\tvar newNFT <- create NFT(\n\t\t\t\tinitID: Art.totalSupply,\n\t\t\t\tmetadata: Metadata(\n\t\t\t\t\tname: name, \n\t\t\t\t\tartist: artist,\n\t\t\t\t\tartistAddress: artistAddress, \n\t\t\t\t\tdescription:description,\n\t\t\t\t\ttype:type,\n\t\t\t\t\tedition:edition,\n\t\t\t\t\tmaxEdition: maxEdition\n\t\t\t\t),\n\t\t\t\tcontentCapability:nil,\n\t\t\t\tcontentId:nil,\n\t\t\t\turl:url, \n\t\t\t\troyalty:royalty\n\t\t\t)\n\t\t\temit Created(id: Art.totalSupply, metadata: newNFT.metadata)\n\n\t\t\tArt.totalSupply = Art.totalSupply + UInt64(1)\n\t\t\treturn <- newNFT\n\t\t}\n\n\t\t//This method can only be called from another contract in the same account. In Versus case it is called from the VersusAdmin that is used to administer the solution\n\t\taccess(account) fun createArtWithPointer(name: String, artist: String, artistAddress:Address, description: String, type: String, contentCapability:Capability<&Content.Collection>, contentId: UInt64, royalty: {String: Royalty}) : @Art.NFT{\n\n\t\t\tlet metadata=Metadata( name: name, artist: artist, artistAddress: artistAddress, description:description, type:type, edition:1, maxEdition:1)\n\t\t\tvar newNFT <- create NFT(initID: Art.totalSupply,metadata: metadata, contentCapability:contentCapability, contentId:contentId, url:nil, royalty:royalty)\n\t\t\temit Created(id: Art.totalSupply, metadata: newNFT.metadata)\n\n\t\t\tArt.totalSupply = Art.totalSupply + UInt64(1)\n\t\t\treturn <- newNFT\n\t\t}\n\n\t\t//This method can only be called from another contract in the same account. In Versus case it is called from the VersusAdmin that is used to administer the solution\n\t\taccess(account) fun makeEdition(original: &NFT, edition: UInt64, maxEdition:UInt64) : @Art.NFT {\n\t\t\tlet metadata=Metadata( name: original.metadata.name, artist:original.metadata.artist, artistAddress:original.metadata.artistAddress, description:original.metadata.description, type:original.metadata.type, edition: edition, maxEdition:maxEdition)\n\t\t\tvar newNFT <- create NFT(initID: Art.totalSupply, metadata: metadata , contentCapability: original.contentCapability, contentId:original.contentId, url:original.url, royalty:original.royalty)\n\t\t\temit Created(id: Art.totalSupply, metadata: newNFT.metadata)\n\t\t\temit Editioned(id: Art.totalSupply, from: original.id, edition:edition, maxEdition:maxEdition)\n\n\t\t\tArt.totalSupply = Art.totalSupply + UInt64(1)\n\t\t\treturn <- newNFT\n\t\t}\n\n\n\t\tinit() {\n\t\t\t// Initialize the total supply\n\t\t\tself.totalSupply = 0\n\t\t\tself.CollectionPublicPath=/public/versusArtCollection\n\t\t\tself.CollectionStoragePath=/storage/versusArtCollection\n\n\t\t\tself.account.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n\t\t\tself.account.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n\t\t\temit ContractInitialized()\n\t\t}\n\t}\n\n"},{"address":"0xd796ff17107bbff6","contractName":"Auction","code":"// This contract allows users to put their NFTs up for sale. Other users\n// can purchase these NFTs with fungible tokens.\n\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport Art from 0xd796ff17107bbff6\nimport NonFungibleToken from 0x1d7e57aa55817448\n\n//This contract was made during OWB so the code here is some of the first cadence code we (0xAlchemist and 0xBjartek wrote)\npub contract Auction {\n\n    // This struct aggreates status for the auction and is exposed in order to create websites using auction information\n    pub struct AuctionStatus{\n        pub let id: UInt64\n        pub let price : UFix64\n        pub let bidIncrement : UFix64\n        pub let bids : UInt64\n        //Active is probably not needed when we have completed and expired above, consider removing it\n        pub let active: Bool\n        pub let timeRemaining : Fix64\n        pub let endTime : Fix64\n        pub let startTime : Fix64\n        pub let metadata: Art.Metadata?\n        pub let artId: UInt64?\n        pub let owner: Address\n        pub let leader: Address?\n        pub let minNextBid: UFix64\n        pub let completed: Bool\n        pub let expired: Bool\n    \n        init(id:UInt64, \n            currentPrice: UFix64, \n            bids:UInt64, \n            active: Bool, \n            timeRemaining:Fix64, \n            metadata: Art.Metadata?,\n            artId: UInt64?,\n            leader:Address?, \n            bidIncrement: UFix64,\n            owner: Address, \n            startTime: Fix64,\n            endTime: Fix64,\n            minNextBid:UFix64,\n            completed: Bool,\n            expired:Bool\n        ) {\n            self.id=id\n            self.price= currentPrice\n            self.bids=bids\n            self.active=active\n            self.timeRemaining=timeRemaining\n            self.metadata=metadata\n            self.artId=artId\n            self.leader= leader\n            self.bidIncrement=bidIncrement\n            self.owner=owner\n            self.startTime=startTime\n            self.endTime=endTime\n            self.minNextBid=minNextBid\n            self.completed=completed\n            self.expired=expired\n        }\n    }\n\n    // The total amount of AuctionItems that have been created\n    pub var totalAuctions: UInt64\n\n    // Events\n\n\n    pub event TokenPurchased(id: UInt64, artId: UInt64, price: UFix64, from:Address, to:Address?)\n    pub event CollectionCreated(owner: Address, cutPercentage: UFix64)\n    pub event Created(tokenID: UInt64, owner: Address, startPrice: UFix64, startTime: UFix64)\n    pub event Bid(tokenID: UInt64, bidderAddress: Address, bidPrice: UFix64)\n    pub event Settled(tokenID: UInt64, price: UFix64)\n    pub event Canceled(tokenID: UInt64)\n    pub event MarketplaceEarned(amount:UFix64, owner: Address)\n\n    // AuctionItem contains the Resources and metadata for a single auction\n    pub resource AuctionItem {\n        \n        //Number of bids made, that is aggregated to the status struct\n        priv var numberOfBids: UInt64\n\n        //The Item that is sold at this auction\n        //It would be really easy to extend this auction with using a NFTCollection here to be able to auction of several NFTs as a single\n        //Lets say if you want to auction of a pack of TopShot moments\n        priv var NFT: @Art.NFT?\n\n        //This is the escrow vault that holds the tokens for the current largest bid\n        priv let bidVault: @FungibleToken.Vault\n\n        //The id of this individual auction\n        pub let auctionID: UInt64\n\n        //The minimum increment for a bid. This is an english auction style system where bids increase\n        priv let minimumBidIncrement: UFix64\n\n        //the time the acution should start at\n        priv var auctionStartTime: UFix64\n\n        //The length in seconds for this auction\n        priv var auctionLength: UFix64\n\n        //Right now the dropitem is not moved from the collection when it ends, it is just marked here that it has ended \n        priv var auctionCompleted: Bool\n\n        // Auction State\n        access(account) var startPrice: UFix64\n        priv var currentPrice: UFix64\n\n        //the capability that points to the resource where you want the NFT transfered to if you win this bid. \n        priv var recipientCollectionCap: Capability<&{Art.CollectionPublic}>?\n\n        //the capablity to send the escrow bidVault to if you are outbid\n        priv var recipientVaultCap: Capability<&{FungibleToken.Receiver}>?\n\n        //the capability for the owner of the NFT to return the item to if the auction is cancelled\n        priv let ownerCollectionCap: Capability<&{Art.CollectionPublic}>\n\n        //the capability to pay the owner of the item when the auction is done\n        priv let ownerVaultCap: Capability<&{FungibleToken.Receiver}>\n\n        init(\n            NFT: @Art.NFT,\n            minimumBidIncrement: UFix64,\n            auctionStartTime: UFix64,\n            startPrice: UFix64, \n            auctionLength: UFix64,\n            ownerCollectionCap: Capability<&{Art.CollectionPublic}>,\n            ownerVaultCap: Capability<&{FungibleToken.Receiver}>,\n        ) {\n\n            Auction.totalAuctions = Auction.totalAuctions + (1 as UInt64)\n            self.NFT <- NFT\n            self.bidVault <- FlowToken.createEmptyVault()\n            self.auctionID = Auction.totalAuctions\n            self.minimumBidIncrement = minimumBidIncrement\n            self.auctionLength = auctionLength\n            self.startPrice = startPrice\n            self.currentPrice = 0.0\n            self.auctionStartTime = auctionStartTime\n            self.auctionCompleted = false\n            self.recipientCollectionCap = nil\n            self.recipientVaultCap = nil\n            self.ownerCollectionCap = ownerCollectionCap\n            self.ownerVaultCap = ownerVaultCap\n            self.numberOfBids=0\n        }\n        \n\n        pub fun content() : String? {\n            return self.NFT?.content()\n        }\n\n        // sendNFT sends the NFT to the Collection belonging to the provided Capability\n        access(contract) fun sendNFT(_ capability: Capability<&{Art.CollectionPublic}>) {\n            if let collectionRef = capability.borrow() {\n                let NFT <- self.NFT <- nil\n                collectionRef.deposit(token: <-NFT!)\n                return\n            } \n            if let ownerCollection=self.ownerCollectionCap.borrow() {\n                let NFT <- self.NFT <- nil\n                ownerCollection.deposit(token: <-NFT!)\n                return \n            } \n        }\n\n        // sendBidTokens sends the bid tokens to the Vault Receiver belonging to the provided Capability\n        access(contract) fun sendBidTokens(_ capability: Capability<&{FungibleToken.Receiver}>) {\n            // borrow a reference to the owner's NFT receiver\n            if let vaultRef = capability.borrow() {\n                let bidVaultRef = &self.bidVault as &FungibleToken.Vault\n                if(bidVaultRef.balance > 0.0) {\n                    vaultRef.deposit(from: <-bidVaultRef.withdraw(amount: bidVaultRef.balance))\n                }\n                return\n            }\n\n            if let ownerRef= self.ownerVaultCap.borrow() {\n                let bidVaultRef = &self.bidVault as &FungibleToken.Vault\n                if(bidVaultRef.balance > 0.0) {\n                    ownerRef.deposit(from: <-bidVaultRef.withdraw(amount: bidVaultRef.balance))\n                }\n                return\n            }\n        }\n\n        pub fun releasePreviousBid() {\n            if let vaultCap = self.recipientVaultCap {\n                self.sendBidTokens(self.recipientVaultCap!)\n                return\n            } \n        }\n\n        //This method should probably use preconditions more \n        pub fun settleAuction(cutPercentage: UFix64, cutVault:Capability<&{FungibleToken.Receiver}> )  {\n\n            pre {\n                !self.auctionCompleted : \"The auction is already settled\"\n                self.NFT != nil: \"NFT in auction does not exist\"\n                self.isAuctionExpired() : \"Auction has not completed yet\"\n            }\n\n            // return if there are no bids to settle\n            if self.currentPrice == 0.0{\n                self.returnAuctionItemToOwner()\n                return\n            }            \n\n\t\t\t\t\t\tif cutPercentage != 0.0 {\n\t\t\t\t\t\t\t//Withdraw cutPercentage to marketplace and put it in their vault\n\t\t\t\t\t\t\tlet amount=self.currentPrice*cutPercentage\n\t\t\t\t\t\t\tlet beneficiaryCut <- self.bidVault.withdraw(amount:amount )\n\n\t\t\t\t\t\t\tlet cutVault=cutVault.borrow()!\n\t\t\t\t\t\t\temit MarketplaceEarned(amount: amount, owner: cutVault.owner!.address)\n\t\t\t\t\t\t\tcutVault.deposit(from: <- beneficiaryCut)\n\t\t\t\t\t\t}\n\n            let artId=self.NFT?.id \n\n            self.sendNFT(self.recipientCollectionCap!)\n            self.sendBidTokens(self.ownerVaultCap)\n\n            self.auctionCompleted = true\n            \n            emit Settled(tokenID: self.auctionID, price: self.currentPrice)\n\n            emit TokenPurchased(id: self.auctionID, \n                artId: artId!, \n                price: self.currentPrice, \n                from: self.ownerVaultCap.address, \n                to: self.recipientCollectionCap?.address)\n\n        }\n\n        pub fun returnAuctionItemToOwner() {\n\n            // release the bidder's tokens\n            self.releasePreviousBid()\n\n            // deposit the NFT into the owner's collection\n            self.sendNFT(self.ownerCollectionCap)\n         }\n\n        //this can be negative if is expired\n        pub fun timeRemaining() : Fix64 {\n            let auctionLength = self.auctionLength\n\n            let startTime = self.auctionStartTime\n            let currentTime = getCurrentBlock().timestamp\n\n            let remaining= Fix64(startTime+auctionLength) - Fix64(currentTime)\n            return remaining\n        }\n\n      \n        pub fun isAuctionExpired(): Bool {\n            let timeRemaining= self.timeRemaining()\n            return timeRemaining < Fix64(0.0)\n        }\n\n        pub fun minNextBid() :UFix64{\n            //If there are bids then the next min bid is the current price plus the increment\n            if self.currentPrice != 0.0 {\n                return self.currentPrice+self.minimumBidIncrement\n            }\n            //else start price\n            return self.startPrice\n        }\n\n        //Extend an auction with a given set of blocks\n        pub fun extendWith(_ amount: UFix64) {\n            self.auctionLength= self.auctionLength + amount\n        }\n\n        pub fun bidder() : Address? {\n            if let vaultCap = self.recipientVaultCap {\n                return vaultCap.address\n            }\n            return nil\n        }\n\n        pub fun currentBidForUser(address:Address): UFix64 {\n             if(self.bidder() == address) {\n                return self.bidVault.balance\n            }\n            return 0.0\n        }\n\n        // This method should probably use preconditions more\n        pub fun placeBid(bidTokens: @FungibleToken.Vault, vaultCap: Capability<&{FungibleToken.Receiver}>, collectionCap: Capability<&{Art.CollectionPublic}>) {\n\n            pre {\n                !self.auctionCompleted : \"The auction is already settled\"\n                self.NFT != nil: \"NFT in auction does not exist\"\n            }\n\n            let bidderAddress=vaultCap.address\n            let collectionAddress=collectionCap.address\n\n            if bidderAddress != collectionAddress {\n              panic(\"you cannot make a bid and send the art to sombody elses collection\")\n            }\n\n            let amountYouAreBidding= bidTokens.balance + self.currentBidForUser(address: bidderAddress)\n            let minNextBid=self.minNextBid()\n            if amountYouAreBidding < minNextBid {\n                panic(\"bid amount + (your current bid) must be larger or equal to the current price + minimum bid increment \".concat(amountYouAreBidding.toString()).concat(\" < \").concat(minNextBid.toString()))\n             }\n\n            if self.bidder() != bidderAddress {\n              if self.bidVault.balance != 0.0 {\n                self.sendBidTokens(self.recipientVaultCap!)\n              }\n            }\n\n            // Update the auction item\n            self.bidVault.deposit(from: <-bidTokens)\n\n            //update the capability of the wallet for the address with the current highest bid\n            self.recipientVaultCap = vaultCap\n\n            // Update the current price of the token\n            self.currentPrice = self.bidVault.balance\n\n            // Add the bidder's Vault and NFT receiver references\n            self.recipientCollectionCap = collectionCap\n            self.numberOfBids=self.numberOfBids+(1 as UInt64)\n\n\n            emit Bid(tokenID: self.auctionID, bidderAddress: bidderAddress, bidPrice: self.currentPrice)\n        }\n\n        pub fun getAuctionStatus() :AuctionStatus {\n\n            var leader:Address?= nil\n            if let recipient = self.recipientVaultCap {\n                leader=recipient.address\n            }\n\n            return AuctionStatus(\n                id:self.auctionID,\n                currentPrice: self.currentPrice, \n                bids: self.numberOfBids,\n                active: !self.auctionCompleted  && !self.isAuctionExpired(),\n                timeRemaining: self.timeRemaining(),\n                metadata: self.NFT?.metadata,\n                artId: self.NFT?.id,\n                leader: leader,\n                bidIncrement: self.minimumBidIncrement,\n                owner: self.ownerVaultCap.address,\n                startTime: Fix64(self.auctionStartTime),\n                endTime: Fix64(self.auctionStartTime+self.auctionLength),\n                minNextBid: self.minNextBid(),\n                completed: self.auctionCompleted,\n                expired: self.isAuctionExpired()\n            )\n        }\n\n        destroy() {\n            log(\"destroy auction\")\n            // send the NFT back to auction owner\n            if self.NFT != nil {\n                self.sendNFT(self.ownerCollectionCap)\n            }\n            \n            // if there's a bidder...\n            if let vaultCap = self.recipientVaultCap {\n                // ...send the bid tokens back to the bidder\n                self.sendBidTokens(vaultCap)\n            }\n\n            destroy self.NFT\n            destroy self.bidVault\n        }\n    }\n\n    \n\n    // AuctionPublic is a resource interface that restricts users to\n    // retreiving the auction price list and placing bids\n    pub resource interface AuctionPublic {\n\n        //It could be argued that this method should not be here in the public contract. I guss it could be an interface of its own\n        //That way when you create an auction you chose if this is a curated auction or an auction where everybody can put their pieces up for sale\n         pub fun createAuction(\n             token: @Art.NFT, \n             minimumBidIncrement: UFix64, \n             auctionLength: UFix64, \n             auctionStartTime: UFix64,\n             startPrice: UFix64, \n             collectionCap: Capability<&{Art.CollectionPublic}>, \n             vaultCap: Capability<&{FungibleToken.Receiver}>) \n\n        pub fun getAuctionStatuses(): {UInt64: AuctionStatus}\n        pub fun getAuctionStatus(_ id:UInt64): AuctionStatus\n\n        pub fun placeBid(\n            id: UInt64, \n            bidTokens: @FungibleToken.Vault, \n            vaultCap: Capability<&{FungibleToken.Receiver}>, \n            collectionCap: Capability<&{Art.CollectionPublic}>\n        )\n    }\n\n    // AuctionCollection contains a dictionary of AuctionItems and provides\n    // methods for manipulating the AuctionItems\n    pub resource AuctionCollection: AuctionPublic {\n\n        // Auction Items\n        access(account) var auctionItems: @{UInt64: AuctionItem}\n        access(contract) var cutPercentage:UFix64 \n        access(contract) let marketplaceVault: Capability<&{FungibleToken.Receiver}>\n\n        init(\n            marketplaceVault: Capability<&{FungibleToken.Receiver}>, \n            cutPercentage: UFix64\n        ) {\n            self.cutPercentage= cutPercentage\n            self.marketplaceVault = marketplaceVault\n            self.auctionItems <- {}\n        }\n\n        pub fun extendAllAuctionsWith(_ amount: UFix64) {\n            for id in self.auctionItems.keys {\n                let itemRef = &self.auctionItems[id] as? &AuctionItem\n                itemRef.extendWith(amount)\n            }\n            \n        }\n\n        pub fun keys() : [UInt64] {\n            return self.auctionItems.keys\n        }\n\n        // addTokenToauctionItems adds an NFT to the auction items and sets the meta data\n        // for the auction item\n        pub fun createAuction(\n            token: @Art.NFT, \n            minimumBidIncrement: UFix64, \n            auctionLength: UFix64, \n            auctionStartTime: UFix64,\n            startPrice: UFix64, \n            collectionCap: Capability<&{Art.CollectionPublic}>, \n            vaultCap: Capability<&{FungibleToken.Receiver}>) {\n            \n            // create a new auction items resource container\n            let item <- Auction.createStandaloneAuction(\n                token: <-token,\n                minimumBidIncrement: minimumBidIncrement,\n                auctionLength: auctionLength,\n                auctionStartTime: auctionStartTime,\n                startPrice: startPrice,\n                collectionCap: collectionCap,\n                vaultCap: vaultCap\n            )\n\n            let id = item.auctionID\n\n            // update the auction items dictionary with the new resources\n            let oldItem <- self.auctionItems[id] <- item\n            destroy oldItem\n\n            let owner= vaultCap.address\n\n            emit Created(tokenID: id, owner: owner, startPrice: startPrice, startTime: auctionStartTime)\n        }\n\n\n        // getAuctionPrices returns a dictionary of available NFT IDs with their current price\n        pub fun getAuctionStatuses(): {UInt64: AuctionStatus} {\n            let priceList: {UInt64: AuctionStatus} = {}\n\n            for id in self.auctionItems.keys {\n                let itemRef = &self.auctionItems[id] as? &AuctionItem\n                priceList[id] = itemRef.getAuctionStatus()\n            }\n            \n            return priceList\n        }\n\n        pub fun getAuctionStatus(_ id:UInt64): AuctionStatus {\n            pre {\n                self.auctionItems[id] != nil:\n                    \"NFT doesn't exist\"\n            }\n\n            // Get the auction item resources\n            let itemRef = &self.auctionItems[id] as &AuctionItem\n            return itemRef.getAuctionStatus()\n\n        }\n\n        // settleAuction sends the auction item to the highest bidder\n        // and deposits the FungibleTokens into the auction owner's account\n        pub fun settleAuction(_ id: UInt64) {\n            let itemRef = &self.auctionItems[id] as &AuctionItem\n            itemRef.settleAuction(cutPercentage: self.cutPercentage, cutVault: self.marketplaceVault)\n\n        }\n\n        pub fun cancelAuction(_ id: UInt64) {\n            pre {\n                self.auctionItems[id] != nil:\n                    \"Auction does not exist\"\n            }\n            let itemRef = &self.auctionItems[id] as &AuctionItem\n            itemRef.returnAuctionItemToOwner()\n            emit Canceled(tokenID: id)\n        }\n\n        // placeBid sends the bidder's tokens to the bid vault and updates the\n        // currentPrice of the current auction item\n        pub fun placeBid(id: UInt64, bidTokens: @FungibleToken.Vault, vaultCap: Capability<&{FungibleToken.Receiver}>, collectionCap: Capability<&{Art.CollectionPublic}>) {\n            pre {\n                self.auctionItems[id] != nil:\n                    \"Auction does not exist in this drop\"\n            }\n\n            // Get the auction item resources\n            let itemRef = &self.auctionItems[id] as &AuctionItem\n            itemRef.placeBid(bidTokens: <- bidTokens, \n              vaultCap:vaultCap, \n              collectionCap:collectionCap)\n\n        }\n\n        destroy() {\n            log(\"destroy auction collection\")\n            // destroy the empty resources\n            destroy self.auctionItems\n        }\n    }\n\n        //this method is used to create a standalone auction that is not part of a collection\n        //we use this to create the unique part of the Versus contract\n        pub fun createStandaloneAuction(\n            token: @Art.NFT, \n            minimumBidIncrement: UFix64, \n            auctionLength: UFix64,\n            auctionStartTime: UFix64,\n            startPrice: UFix64, \n            collectionCap: Capability<&{Art.CollectionPublic}>, \n            vaultCap: Capability<&{FungibleToken.Receiver}>) : @AuctionItem {\n            \n            // create a new auction items resource container\n            return  <- create AuctionItem(\n                NFT: <-token,\n                minimumBidIncrement: minimumBidIncrement,\n                auctionStartTime: auctionStartTime,\n                startPrice: startPrice,\n                auctionLength: auctionLength,\n                ownerCollectionCap: collectionCap,\n                ownerVaultCap: vaultCap\n            )\n        }\n    // createAuctionCollection returns a new AuctionCollection resource to the caller\n    pub fun createAuctionCollection(marketplaceVault: Capability<&{FungibleToken.Receiver}>,cutPercentage: UFix64): @AuctionCollection {\n        let auctionCollection <- create AuctionCollection(\n            marketplaceVault: marketplaceVault, \n            cutPercentage: cutPercentage\n        )\n\n        emit CollectionCreated(owner: marketplaceVault.address, cutPercentage: cutPercentage)\n        return <- auctionCollection\n    }\n\n    init() {\n        self.totalAuctions = (0 as UInt64)\n    }   \n}\n \n"},{"address":"0xd796ff17107bbff6","contractName":"Content","code":"pub contract Content {\n\n    pub var totalSupply: UInt64\n\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPrivatePath: PrivatePath\n\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n    pub event Created(id: UInt64)\n\n    pub resource Blob {\n        pub let id: UInt64\n\n        access(contract) var content: String\n\n        init(initID: UInt64, content: String) {\n            self.id = initID\n            self.content=content\n        }\n    }\n\n    //return the content for this NFT\n    pub resource interface PublicContent {\n        pub fun content(_ id: UInt64): String? \n    }\n\n    pub resource Collection: PublicContent {\n        pub var contents: @{UInt64: Blob}\n\n        init () {\n            self.contents <- {}\n        }\n\n        // withdraw removes an NFT from the collection and moves it to the caller\n        pub fun withdraw(withdrawID: UInt64): @Blob {\n            let token <- self.contents.remove(key: withdrawID) ?? panic(\"missing content\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // deposit takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        pub fun deposit(token: @Blob) {\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.contents[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // getIDs returns an array of the IDs that are in the collection\n        pub fun getIDs(): [UInt64] {\n            return self.contents.keys\n        }\n\n        pub fun content(_ id: UInt64) : String {\n            return self.contents[id]?.content ?? panic(\"Content blob does not exist\")\n        }\n\n        destroy() {\n            destroy self.contents\n        }\n    }\n\n    access(account) fun createEmptyCollection(): @Content.Collection {\n        return <- create Collection()\n    }\n\n\n    access(account) fun createContent(_ content: String) : @Content.Blob {\n\n        var newNFT <- create Blob(initID: Content.totalSupply, content:content)\n        emit Created(id: Content.totalSupply)\n\n        Content.totalSupply = Content.totalSupply + UInt64(1)\n        return <- newNFT\n    }\n\n    init() {\n        // Initialize the total supply\n        self.totalSupply = 0\n        self.CollectionPrivatePath=/private/versusContentCollection\n        self.CollectionStoragePath=/storage/versusContentCollection\n\n        let account =self.account\n        account.save(<- Content.createEmptyCollection(), to: Content.CollectionStoragePath)\n        account.link<&Content.Collection>(Content.CollectionPrivatePath, target: Content.CollectionStoragePath)\n\n        emit ContractInitialized()\n    }\n}\n"},{"address":"0xd796ff17107bbff6","contractName":"Marketplace","code":"import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport Art from 0xd796ff17107bbff6\nimport NonFungibleToken from 0x1d7e57aa55817448\n\n// A standard marketplace contract only hardcoded against Versus art that pay out Royalty as stored int he Art NFT\n\npub contract Marketplace {\n\n    pub let CollectionStoragePath: StoragePath\n    pub let CollectionPublicPath: PublicPath\n\n    // Event that is emitted when a new NFT is put up for sale\n    pub event ForSale(id: UInt64, price: UFix64, from: Address)\n\n    pub event SaleItem(id: UInt64, seller: Address, price: UFix64, active: Bool, title: String, artist: String, edition: UInt64, maxEdition: UInt64, cacheKey: String)\n\n    // Event that is emitted when the price of an NFT changes\n    pub event PriceChanged(id: UInt64, newPrice: UFix64)\n    \n    // Event that is emitted when a token is purchased\n    pub event TokenPurchased(id: UInt64, artId: UInt64, price: UFix64, from:Address, to:Address)\n\n    pub event RoyaltyPaid(id:UInt64, amount: UFix64, to:Address, name:String)\n\n    // Event that is emitted when a seller withdraws their NFT from the sale\n    pub event SaleWithdrawn(id: UInt64, from:Address)\n\n    // Interface that users will publish for their Sale collection\n    // that only exposes the methods that are supposed to be public\n    //\n    pub resource interface SalePublic {\n        pub fun purchase(tokenID: UInt64, recipientCap: Capability<&{Art.CollectionPublic}>, buyTokens: @FungibleToken.Vault)\n        pub fun getSaleItem(tokenID: UInt64): MarketplaceData\n        pub fun getIDs(): [UInt64]\n        pub fun listSaleItems() : [MarketplaceData]\n        pub fun getContent(tokenID: UInt64) : String\n     }\n\n     pub struct MarketplaceData {\n        pub let id: UInt64\n        pub let art: Art.Metadata\n        pub let cacheKey: String\n        pub let price: UFix64\n        init( id: UInt64, art: Art.Metadata, cacheKey:String, price: UFix64) {\n            self.art= art\n            self.id=id\n            self.price=price\n            self.cacheKey=cacheKey\n        }\n    }\n\n    // SaleCollection\n    //\n    // NFT Collection object that allows a user to put their NFT up for sale\n    // where others can send fungible tokens to purchase it\n    //\n    pub resource SaleCollection: SalePublic {\n\n        // Dictionary of the NFTs that the user is putting up for sale\n        pub var forSale: @{UInt64: Art.NFT}\n\n        // Dictionary of the prices for each NFT by ID\n        pub var prices: {UInt64: UFix64}\n\n        // The fungible token vault of the owner of this sale.\n        // When someone buys a token, this resource can deposit\n        // tokens into their account.\n        access(account) let ownerVault: Capability<&AnyResource{FungibleToken.Receiver}>\n\n        init (vault: Capability<&AnyResource{FungibleToken.Receiver}>) {\n            self.forSale <- {}\n            self.ownerVault = vault\n            self.prices = {}\n        }\n\n        pub fun getContent(tokenID: UInt64) : String {\n            return self.forSale[tokenID]?.content()!\n        }\n\n\t\t\t\tpub fun getArtType(tokenID: UInt64) : String {\n\t\t\t\t\treturn self.forSale[tokenID]?.metadata?.type!\n\t\t\t\t}\n             \n        pub fun listSaleItems() : [MarketplaceData] {\n          var saleItems: [MarketplaceData] = []\n\n          for id in self.getIDs() {\n            saleItems.append(self.getSaleItem(tokenID: id))\n          }\n          return saleItems\n        }\n\n          pub fun borrowArt(id: UInt64): &{Art.Public}? {\n            if self.forSale[id] != nil {\n                return &self.forSale[id] as &Art.NFT\n            } else {\n                return nil\n            }\n        }\n\n        pub fun withdraw(tokenID: UInt64): @Art.NFT {\n \n            let price=self.prices.remove(key: tokenID)\n            // remove and return the token\n            let token <- self.forSale.remove(key: tokenID) ?? panic(\"missing NFT\")\n           \n            emit SaleWithdrawn(id: tokenID, from: self.ownerVault.address)\n\n            emit SaleItem(id: token.id, \n              seller: self.ownerVault.address, \n              price: price ?? 0.0, \n              active: false,\n              title: token.metadata.name,\n              artist: token.metadata.artist,\n              edition: token.metadata.edition, \n              maxEdition: token.metadata.maxEdition,\n              cacheKey: token.cacheKey())\n\n            return <-token\n        }\n\n        // listForSale lists an NFT for sale in this collection\n        pub fun listForSale(token: @Art.NFT, price: UFix64) {\n            emit SaleItem(id: token.id, \n              seller: self.ownerVault.address, \n              price: price, \n              active: true,\n              title: token.metadata.name,\n              artist: token.metadata.artist,\n              edition: token.metadata.edition, \n              maxEdition: token.metadata.maxEdition,\n              cacheKey: token.cacheKey())\n\n            let id = token.id\n\n            // store the price in the price array\n            self.prices[id] = price\n\n            // put the NFT into the the forSale dictionary\n            let oldToken <- self.forSale[id] <- token\n            destroy oldToken\n\n            emit ForSale(id: id, price: price, from: self.ownerVault.address)\n        }\n\n        // changePrice changes the price of a token that is currently for sale\n        pub fun changePrice(tokenID: UInt64, newPrice: UFix64) {\n            self.prices[tokenID] = newPrice\n            emit PriceChanged(id: tokenID, newPrice: newPrice)\n\n            let token= self.borrowArt(id: tokenID)!\n            emit SaleItem(id: token.id, \n              seller: self.ownerVault.address, \n              price: newPrice, \n              active: true,\n              title: token.metadata.name,\n              artist: token.metadata.artist,\n              edition: token.metadata.edition, \n              maxEdition: token.metadata.maxEdition,\n              cacheKey: token.cacheKey())\n        }\n\n        // purchase lets a user send tokens to purchase an NFT that is for sale\n        pub fun purchase(tokenID: UInt64, recipientCap: Capability<&{Art.CollectionPublic}>, buyTokens: @FungibleToken.Vault) {\n            pre {\n                self.forSale[tokenID] != nil && self.prices[tokenID] != nil:\n                    \"No token matching this ID for sale!\"\n                buyTokens.balance >= (self.prices[tokenID] ?? 0.0):\n                    \"Not enough tokens to by the NFT!\"\n            }\n\n            let recipient=recipientCap.borrow()!\n\n            // get the value out of the optional\n            let price = self.prices[tokenID]!\n            \n            self.prices[tokenID] = nil\n\n            let vaultRef = self.ownerVault.borrow()\n                ?? panic(\"Could not borrow reference to owner token vault\")\n            \n            let token <-self.withdraw(tokenID: tokenID)\n            let artId = token.id\n\n            for royality in token.royalty.keys {\n                let royaltyData= token.royalty[royality]!\n                if let wallet= royaltyData.wallet.borrow() {\n                    let amount= price * royaltyData.cut\n                    let royaltyWallet <- buyTokens.withdraw(amount: amount)\n                    wallet.deposit(from: <- royaltyWallet)\n                    emit RoyaltyPaid(id: tokenID, amount:amount, to: royaltyData.wallet.address, name:royality)\n                } \n            }\n            // deposit the purchasing tokens into the owners vault\n            vaultRef.deposit(from: <-buyTokens)\n\n            // deposit the NFT into the buyers collection\n            recipient.deposit(token: <- token)\n\n            emit TokenPurchased(id: tokenID, artId: artId, price: price, from: vaultRef.owner!.address, to:  recipient.owner!.address)\n        }\n\n        // idPrice returns the price of a specific token in the sale\n        pub fun getSaleItem(tokenID: UInt64): MarketplaceData {\n\n            let metadata=self.forSale[tokenID]?.metadata\n            let cacheKey=self.forSale[tokenID]?.cacheKey()\n            return MarketplaceData(\n                id: tokenID,\n                art: metadata!,\n                cacheKey: cacheKey!,\n                price: self.prices[tokenID]!\n            )\n        }\n\n        // getIDs returns an array of token IDs that are for sale\n        pub fun getIDs(): [UInt64] {\n            return self.forSale.keys\n        }\n\n        destroy() {\n            destroy self.forSale\n        }\n    }\n\n    // createCollection returns a new collection resource to the caller\n    pub fun createSaleCollection(ownerVault: Capability<&{FungibleToken.Receiver}>): @SaleCollection {\n        return <- create SaleCollection(vault: ownerVault)\n    }\n\n    pub init() {\n        self.CollectionPublicPath= /public/versusArtMarketplace\n        self.CollectionStoragePath= /storage/versusArtMarketplace\n    }\n\n}\n \n"},{"address":"0xd796ff17107bbff6","contractName":"Profile","code":"/*\n* Inspiration: https://flow-view-source.com/testnet/account/0xba1132bc08f82fe2/contract/Ghost\n*/\n\nimport FungibleToken from 0xf233dcee88fe0abe\n\npub contract Profile {\n  pub let publicPath: PublicPath\n  pub let storagePath: StoragePath\n  \n  \n  //and event emitted when somebody follows another user\n  pub event Follow(follower:Address, following: Address, tags: [String])\n\n  //an event emitted when somebody unfollows somebody\n  pub event Unfollow(follower:Address, unfollowing: Address)\n\n  //and event emitted when a user verifies something\n  pub event Verification(account:Address, message:String)\n\n  /* \n  Represents a Fungible token wallet with a name and a supported type.\n   */\n  pub struct Wallet {\n    pub let name: String\n    pub let receiver: Capability<&{FungibleToken.Receiver}>\n    pub let balance: Capability<&{FungibleToken.Balance}>\n    pub let accept: Type\n    pub let tags: [String]\n\n    init(\n      name: String,\n      receiver: Capability<&{FungibleToken.Receiver}>,\n      balance: Capability<&{FungibleToken.Balance}>,\n      accept: Type,\n      tags: [String]\n    ) {\n      self.name=name\n      self.receiver=receiver\n      self.balance=balance\n      self.accept=accept\n      self.tags=tags\n    }\n  }\n\n  /*\n  \n   Represent a collection of a Resource that you want to expose\n   Since NFT standard is not so great at just add Type and you have to use instanceOf to check for now\n   */\n  pub struct ResourceCollection {\n    pub let collection: Capability\n    pub let tags: [String]\n    pub let type: Type\n    pub let name: String\n\n    init(name: String, collection:Capability, type: Type, tags: [String]) {\n      self.name=name\n      self.collection=collection\n      self.tags=tags\n      self.type=type\n    }\n  }\n\n\n  pub struct CollectionProfile{\n    pub let tags: [String]\n    pub let type: String\n    pub let name: String\n\n    init(_ collection: ResourceCollection){\n      self.name=collection.name\n      self.type=collection.type.identifier\n      self.tags=collection.tags\n    }\n  }\n\n  /*\n    A link that you could add to your profile\n   */\n  pub struct Link {\n     pub let url: String\n     pub let title: String\n     pub let type: String\n\n     init(title: String, type: String, url: String) {\n       self.url=url\n       self.title=title\n       self.type=type\n     }\n  }\n  /*\n    Information about a connection between one profile and another.\n   */\n  pub struct FriendStatus {\n    pub let follower: Address\n    pub let following:Address\n    pub let tags: [String]\n\n    init(follower: Address, following:Address, tags: [String]) {\n      self.follower=follower\n      self.following=following \n      self.tags= tags\n    }\n  }\n\n  pub struct WalletProfile {\n    pub let name: String\n    pub let balance: UFix64\n    pub let accept:  String\n    pub let tags: [String] \n\n    init(_ wallet: Wallet) {\n      self.name=wallet.name\n      self.balance=wallet.balance.borrow()?.balance ?? 0.0 \n      self.accept=wallet.accept.identifier\n      self.tags=wallet.tags\n    }\n  }\n\n  pub struct UserProfile {\n    pub let address: Address\n    pub let name: String\n    pub let description: String\n    pub let tags: [String]\n    pub let avatar: String\n    pub let links: [Link]\n    pub let wallets: [WalletProfile]\n    pub let collections: [CollectionProfile]\n    pub let following: [FriendStatus]\n    pub let followers: [FriendStatus]\n    pub let allowStoringFollowers: Bool\n\n    init(\n      address: Address,\n      name: String,\n      description: String, \n      tags: [String],\n      avatar: String, \n      links: [Link],\n      wallets: [WalletProfile],\n      collections: [CollectionProfile],\n      following: [FriendStatus],\n      followers: [FriendStatus],\n      allowStoringFollowers:Bool) {\n        self.address=address\n        self.name=name\n        self.description=description\n        self.tags=tags\n        self.avatar=avatar\n        self.links=links\n        self.collections=collections\n        self.wallets=wallets\n        self.following=following\n        self.followers=followers\n        self.allowStoringFollowers=allowStoringFollowers\n      }\n  }\n  pub resource interface Public {\n    pub fun getName(): String\n    pub fun getDescription(): String\n    pub fun getTags(): [String]\n    pub fun getAvatar(): String\n    pub fun getCollections(): [ResourceCollection] \n    pub fun follows(_ address: Address) : Bool\n    pub fun getFollowers(): [FriendStatus]\n    pub fun getFollowing(): [FriendStatus]\n    pub fun getWallets() : [Wallet]\n    pub fun getLinks() : [Link]\n    pub fun deposit(from: @FungibleToken.Vault)\n    pub fun supportedFungigleTokenTypes() : [Type]\n    pub fun asProfile() : UserProfile\n    pub fun isBanned(_ val: Address): Bool\n    //TODO: should getBanned be here?\n    \n    access(contract) fun internal_addFollower(_ val: FriendStatus)\n    access(contract) fun internal_removeFollower(_ address: Address) \n  }\n  \n  pub resource interface Owner {\n    pub fun setName(_ val: String) {\n      pre {\n        val.length <= 16: \"Name must be 16 or less characters\"\n      }\n    }\n\n    pub fun setAvatar(_ val: String){\n      pre {\n        val.length <= 255: \"Avatar must be 255 characters or less\"\n      }\n    }\n\n    pub fun setTags(_ val: [String])  {\n       pre {\n        Profile.verifyTags(tags: val, tagLength:10, tagSize:3) : \"cannot have more then 3 tags of length 10\"\n      }\n    }   \n\n    //validate length of description to be 255 or something?\n    pub fun setDescription(_ val: String) {\n      pre {\n        val.length <= 255: \"Description must be 255 characters or less\"\n      }\n    }\n\n    pub fun follow(_ address: Address, tags:[String]) {\n       pre {\n        Profile.verifyTags(tags: tags, tagLength:10, tagSize:3) : \"cannot have more then 3 tags of length 10\"\n      }\n    }\n    pub fun unfollow(_ address: Address)\n\n    pub fun removeCollection(_ val: String)\n    pub fun addCollection(_ val: ResourceCollection)\n\n    pub fun addWallet(_ val : Wallet) \n    pub fun removeWallet(_ val: String)\n    pub fun setWallets(_ val: [Wallet])\n\n    pub fun addLink(_ val: Link)\n    pub fun removeLink(_ val: String)\n\n    //Verify that this user has signed something.\n    pub fun verify(_ val:String) \n\n    //A user must be able to remove a follower since this data in your account is added there by another user\n    pub fun removeFollower(_ val: Address)\n\n    //manage bans\n    pub fun addBan(_ val: Address)\n    pub fun removeBan(_ val: Address)\n    pub fun getBans(): [Address]\n\n    //Set if user is allowed to store followers or now\n    pub fun setAllowStoringFollowers(_ val: Bool)\n  }\n  \n\n  pub resource User: Public, Owner, FungibleToken.Receiver {\n    access(self) var name: String\n    access(self) var description: String\n    access(self) var avatar: String\n    access(self) var tags: [String]\n    access(self) var followers: {Address: FriendStatus}\n    access(self) var bans: {Address: Bool}\n    access(self) var following: {Address: FriendStatus}\n    access(self) var collections: {String: ResourceCollection}\n    access(self) var wallets: [Wallet]\n    access(self) var links: {String: Link}\n    access(self) var allowStoringFollowers: Bool\n    \n    init(name:String, description: String, allowStoringFollowers: Bool, tags: [String]) {\n      self.name = name\n      self.description=description\n      self.tags=tags\n      self.avatar = \"https://avatars.onflow.org/avatar/ghostnote\"\n      self.followers = {}\n      self.following = {}\n      self.collections={}\n      self.wallets=[]\n      self.links={}\n      self.allowStoringFollowers=allowStoringFollowers\n      self.bans={}\n\n    }\n\n    pub fun addBan(_ val: Address) { self.bans[val]= true}\n    pub fun removeBan(_ val:Address) { self.bans.remove(key: val) }\n    pub fun getBans() : [Address] { return self.bans.keys }\n    pub fun isBanned(_ val:Address) : Bool { return self.bans.containsKey(val)}\n\n    pub fun setAllowStoringFollowers(_ val: Bool) {\n      self.allowStoringFollowers=val\n    }\n\n    pub fun verify(_ val:String) {\n        emit Verification(account: self.owner!.address, message:val)\n    }\n\n    pub fun asProfile() : UserProfile {\n       let wallets: [WalletProfile]=[]\n       for w in self.wallets {\n        wallets.append(WalletProfile(w))\n       }\n\n       let collections:[CollectionProfile]=[]\n       for c in self.getCollections() {\n         collections.append(CollectionProfile(c))\n       }\n\n       return UserProfile(\n         address: self.owner!.address,\n         name: self.getName(),\n         description: self.getDescription(),\n         tags: self.getTags(),\n         avatar: self.getAvatar(),\n         links: self.getLinks(),\n         wallets: wallets, \n         collections: collections,\n         following: self.getFollowing(),\n         followers: self.getFollowers(),\n         allowStoringFollowers: self.allowStoringFollowers\n       )\n    }\n\n    pub fun getLinks() : [Link] {\n      return self.links.values\n    }\n\n    pub fun addLink(_ val: Link) {\n      self.links[val.title]=val\n    }\n\n    pub fun removeLink(_ val: String) {\n      self.links.remove(key: val)\n    }\n    \n    pub fun supportedFungigleTokenTypes() : [Type] { \n        let types: [Type] =[]\n        for w in self.wallets {\n          if !types.contains(w.accept) {\n            types.append(w.accept)\n          }\n        }\n        return types\n    }\n\n    pub fun deposit(from: @FungibleToken.Vault) {\n      for w in self.wallets {\n        if from.isInstance(w.accept) {\n          w.receiver.borrow()!.deposit(from: <- from)\n          return\n        }\n      } \n      let identifier=from.getType().identifier\n      //TODO: I need to destroy here for this to compile, but WHY?\n      destroy from\n      panic(\"could not find a supported wallet for:\".concat(identifier))\n    }\n\n\n    pub fun getWallets() : [Wallet] { return self.wallets}\n    pub fun addWallet(_ val: Wallet) { self.wallets.append(val) }\n    pub fun removeWallet(_ val: String) {\n      let numWallets=self.wallets.length\n      var i=0\n      while(i < numWallets) {\n        if self.wallets[i].name== val {\n          self.wallets.remove(at: i)\n          return\n        }\n        i=i+1\n      }\n    }\n\n    pub fun setWallets(_ val: [Wallet]) { self.wallets=val }\n\n    pub fun removeFollower(_ val: Address) {\n      self.followers.remove(key:val)\n    }\n\n    pub fun follows(_ address: Address) : Bool {\n      return self.following.containsKey(address)\n    }\n\n    pub fun getName(): String { return self.name }\n    pub fun getDescription(): String{ return self.description}\n    pub fun getTags(): [String] { return self.tags}\n    pub fun getAvatar(): String { return self.avatar }\n    pub fun getFollowers(): [FriendStatus] { return self.followers.values }\n    pub fun getFollowing(): [FriendStatus] { return self.following.values }\n    \n    pub fun setName(_ val: String) { self.name = val }\n    pub fun setAvatar(_ val: String) { self.avatar = val }\n    pub fun setDescription(_ val: String) { self.description=val}\n    pub fun setTags(_ val: [String]) { self.tags=val}\n\n    pub fun removeCollection(_ val: String) { self.collections.remove(key: val)}\n    pub fun addCollection(_ val: ResourceCollection) { self.collections[val.name]=val}\n    pub fun getCollections(): [ResourceCollection] { return self.collections.values}\n\n\n    pub fun follow(_ address: Address, tags:[String]) {\n      let friendProfile=Profile.find(address)\n      let owner=self.owner!.address\n      let status=FriendStatus(follower:owner, following:address, tags:tags)\n\n      self.following[address] = status\n      friendProfile.internal_addFollower(status)\n      emit Follow(follower:owner, following: address, tags:tags)\n    }\n    \n    pub fun unfollow(_ address: Address) {\n      self.following.remove(key: address)\n      Profile.find(address).internal_removeFollower(self.owner!.address)\n      emit Unfollow(follower: self.owner!.address, unfollowing:address)\n    }\n    \n    access(contract) fun internal_addFollower(_ val: FriendStatus) {\n      if self.allowStoringFollowers && !self.bans.containsKey(val.follower) {\n        self.followers[val.follower] = val\n      }\n    }\n    \n    access(contract) fun internal_removeFollower(_ address: Address) {\n      if self.followers.containsKey(address) {\n        self.followers.remove(key: address)\n      }\n    }\n    \n  }\n\n   pub fun find(_ address: Address) : &{Profile.Public} {\n        return getAccount(address)\n        .getCapability<&{Profile.Public}>(Profile.publicPath)!\n        .borrow()!\n    }\n  \n  pub fun createUser(name: String, description:String, allowStoringFollowers: Bool, tags:[String]) : @Profile.User {\n    pre {\n      Profile.verifyTags(tags: tags, tagLength:10, tagSize:3) : \"cannot have more then 3 tags of length 10\"\n      name.length <= 16: \"Name must be 16 or less characters\"\n      description.length <= 255: \"Descriptions must be 255 or less characters\"\n    }\n    return <- create Profile.User(name: name, description: description, allowStoringFollowers: allowStoringFollowers, tags: tags)\n  }\n\n  pub fun verifyTags(tags : [String], tagLength: Int, tagSize: Int): Bool {\n    if tags.length > tagSize {\n      return false\n    }\n\n    for t in tags {\n      if t.length > tagLength {\n        return false\n      }\n    }\n    return true\n  }\n\n  init() {\n    self.publicPath = /public/VersusUserProfile\n    self.storagePath = /storage/VersusUserProfile\n  }\n\n\n  \n}\n"},{"address":"0xd796ff17107bbff6","contractName":"Versus","code":"import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Art from 0xd796ff17107bbff6\nimport Content from 0xd796ff17107bbff6\nimport Auction from 0xd796ff17107bbff6\nimport Profile from 0xd796ff17107bbff6\n\n/*\nThe main contract in the Versus auction system.\n\nA versions auction contains a single auction and a group of auctions and either of them will be fulfilled while the other will be cancelled\nCurrently this is modeled as 1 vs x, but It could easily be modeled as x vs y  so you could have 5 editions vs 10 editions if you want to\n\nThe auctions themselves are not implemented in this contract but rather in the Auction contract. The goal here is to be able to\nreuse the Auction contract for other things if somebody would want that.\n\n*/\npub contract Versus {\n\n\t//A set of capability and storage paths used in this contract\n\tpub let VersusAdminPublicPath: PublicPath\n\tpub let VersusAdminStoragePath: StoragePath\n\tpub let CollectionStoragePath: StoragePath\n\tpub let CollectionPublicPath: PublicPath\n\tpub let CollectionPrivatePath: PrivatePath\n\n\t//counter for drops that is incremented every time there is a new versus drop made\n\tpub var totalDrops: UInt64\n\n\t//emitted when a drop is extended\n\tpub event DropExtended(name: String, artist: String, dropId: UInt64, extendWith: Fix64, extendTo: Fix64)\n\n\tpub event Bid(name: String, artist: String, edition:String, bidder: Address, price: UFix64, dropId: UInt64, auctionId:UInt64)\n\t//emitted when a bid is made\n\tpub event ExtendedBid(name: String, artist: String, edition:String, bidderAddress: Address, bidderName: String, price: UFix64, oldBidderAddress: Address?, oldBidderName:String, oldPrice:UFix64?, dropId: UInt64, auctionId:UInt64, auctionEndAt: Fix64, extendWith: Fix64, cacheKey: String, oldLeader:String, newLeader:String)\n\n\t//emitted when a drop is created\n\tpub event DropCreated(name: String, artist: String, editions: UInt64, owner:Address, dropId: UInt64)\n\n\tpub event DropDestroyed(dropId:UInt64)\n\n\t//emitted when a drop is settled, that is it ends and either the uniqe or the edition side wins\n\tpub event Settle(name: String, artist: String, winner: String, price:UFix64, dropId: UInt64)\n\n\t//emitted when the winning side in the auction changes\n\tpub event LeaderChanged(name: String, artist: String, winning: String, dropId:UInt64)\n\n\t//A Drop in versus represents a single auction vs an editioned auction\n\tpub resource Drop {\n\n\t\taccess(contract) let uniqueAuction: @Auction.AuctionItem\n\t\taccess(contract) let editionAuctions: @Auction.AuctionCollection\n\t\taccess(contract) let dropID: UInt64\n\n\t\t//this is used to be able to query events for a drop from a given start point\n\t\taccess(contract) var firstBidBlock: UInt64?\n\t\taccess(contract) var settledAt: UInt64?\n\n\t\taccess(contract) var extensionOnLateBid: UFix64\n\n\n\t\t//Store metadata here would allow us to show this after the drop has ended. The NFTS are gone then but the  metadta remains here\n\t\taccess(contract) let metadata: Art.Metadata\n\n\t\t//these two together are a pointer to the content in the Drop. Storing them here means we can show the art after the drop has ended\n\t\taccess(contract) var contentId: UInt64\n\t\taccess(contract) var contentCapability: Capability<&Content.Collection>\n\n\t\tinit( uniqueAuction: @Auction.AuctionItem, editionAuctions: @Auction.AuctionCollection, extensionOnLateBid: UFix64, contentId: UInt64, contentCapability: Capability<&Content.Collection>) {\n\n\t\t\tVersus.totalDrops = Versus.totalDrops + (1 as UInt64)\n\n\t\t\tself.dropID=Versus.totalDrops\n\t\t\tself.uniqueAuction <-uniqueAuction\n\t\t\tself.editionAuctions <- editionAuctions\n\t\t\tself.firstBidBlock=nil\n\t\t\tself.settledAt=nil\n\t\t\tself.metadata=self.uniqueAuction.getAuctionStatus().metadata!\n\t\t\tself.extensionOnLateBid=extensionOnLateBid\n\t\t\tself.contentId=contentId\n\t\t\tself.contentCapability=contentCapability\n\t\t}\n\n\t\tdestroy(){\n\t\t\tlog(\"Destroy versus\")\n\t\t\tdestroy self.uniqueAuction\n\t\t\tdestroy self.editionAuctions\n\t\t\temit DropDestroyed(dropId: self.dropID)\n\t\t}\n\n\t\tpub fun getContent() : String {\n\t\t\tlet contentCollection= self.contentCapability.borrow()!\n\t\t\treturn contentCollection.content(self.contentId)\n\t\t}\n\n\t\t//Returns a DropStatus struct that could be used in a script to show information about the drop\n\t\tpub fun getDropStatus() : DropStatus {\n\t\t\tlet uniqueRef = &self.uniqueAuction as &Auction.AuctionItem\n\t\t\tlet editionRef= &self.editionAuctions as &Auction.AuctionCollection\n\n\t\t\tlet editionStatuses= editionRef.getAuctionStatuses()\n\t\t\tvar editionPrice:UFix64= 0.0\n\n\t\t\tlet editionDropAcutionStatus: {UInt64:DropAuctionStatus} = {}\n\t\t\tfor es in editionStatuses.keys {\n\t\t\t\tvar status=editionStatuses[es]!\n\t\t\t\teditionDropAcutionStatus[es] = DropAuctionStatus(status)\n\t\t\t\teditionPrice = editionPrice + status.price\n\t\t\t}\n\n\t\t\tlet uniqueStatus=uniqueRef.getAuctionStatus()\n\n\t\t\tvar winningStatus=\"\"\n\t\t\tvar difference=0.0\n\t\t\tif editionPrice > uniqueStatus.price {\n\t\t\t\twinningStatus=\"EDITIONED\"\n\t\t\t\tdifference = editionPrice - uniqueStatus.price\n\t\t\t} else if (editionPrice == uniqueStatus.price) {\n\t\t\t\twinningStatus=\"TIE\"\n\t\t\t\tdifference=0.0\n\t\t\t} else {\n\t\t\t\tdifference=uniqueStatus.price - editionPrice\n\t\t\t\twinningStatus=\"UNIQUE\"\n\t\t\t}\n\n\t\t\tlet block=getCurrentBlock()\n\t\t\tlet time=Fix64(block.timestamp)\n\n\t\t\tvar started = uniqueStatus.startTime < time\n\t\t\tvar active=true\n\t\t\tif !started {\n\t\t\t\tactive=false\n\t\t\t} else if uniqueStatus.completed {\n\t\t\t\tactive=false\n\t\t\t} else if uniqueStatus.expired && winningStatus != \"TIE\" {\n\t\t\t\tactive=false\n\t\t\t}\n\t\t\treturn DropStatus(\n\t\t\t\tdropId: self.dropID,\n\t\t\t\tuniqueStatus: uniqueStatus,\n\t\t\t\teditionsStatuses: editionDropAcutionStatus,\n\t\t\t\teditionPrice: editionPrice,\n\t\t\t\tstatus: winningStatus,\n\t\t\t\tfirstBidBlock: self.firstBidBlock,\n\t\t\t\tdifference: difference,\n\t\t\t\tmetadata: self.metadata,\n\t\t\t\tsettledAt: self.settledAt,\n\t\t\t\tactive: active,\n\t\t\t\tstartPrice: uniqueRef.startPrice\n\t\t\t)\n\t\t}\n\n\t\tpub fun calculateStatus(edition:UFix64, unique: UFix64) : String{\n\t\t\tvar winningStatus=\"\"\n\t\t\tif edition > unique{\n\t\t\t\twinningStatus=\"EDITIONED\"\n\t\t\t} else if (edition== unique) {\n\t\t\t\twinningStatus=\"TIE\"\n\t\t\t} else {\n\t\t\t\twinningStatus=\"UNIQUE\"\n\t\t\t}\n\t\t\treturn winningStatus\n\t\t}\n\n\t\tpub fun settle(cutPercentage:UFix64, vault: Capability<&{FungibleToken.Receiver}> ) {\n\t\t\tlet status=self.getDropStatus()\n\n\t\t\tif status.settledAt != nil {\n\t\t\t\tpanic(\"Drop has already been settled\")\n\t\t\t}\n\n\t\t\tif status.expired == false {\n\t\t\t\tpanic(\"Auction has not completed yet\")\n\t\t\t}\n\n\t\t\tlet winning=status.winning\n\t\t\tvar price=0.0\n\t\t\tif winning == \"UNIQUE\" {\n\t\t\t\tself.uniqueAuction.settleAuction(cutPercentage: cutPercentage, cutVault: vault)\n\t\t\t\tself.cancelAllEditionedAuctions()\n\t\t\t\tprice=status.uniquePrice\n\t\t\t} else if winning == \"EDITIONED\" {\n\t\t\t\tself.uniqueAuction.returnAuctionItemToOwner()\n\t\t\t\tself.settleAllEditionedAuctions()\n\t\t\t\tprice=status.editionPrice\n\t\t\t} else {\n\t\t\t\tpanic(\"tie\")\n\t\t\t}\n\n\t\t\tself.settledAt=getCurrentBlock().height\n\t\t\temit Settle(name: status.metadata.name, artist: status.metadata.artist, winner: winning, price: price, dropId: self.dropID )\n\t\t}\n\n\n\t\tpub fun settleAllEditionedAuctions() {\n\t\t\tfor id in self.editionAuctions.keys() {\n\t\t\t\tself.editionAuctions.settleAuction(id)\n\t\t\t}\n\t\t}\n\n\t\tpub fun cancelAllEditionedAuctions() {\n\t\t\tfor id in self.editionAuctions.keys() {\n\t\t\t\tself.editionAuctions.cancelAuction(id)\n\t\t\t}\n\t\t}\n\n\t\tpriv fun getAuction(auctionId:UInt64): &Auction.AuctionItem {\n\t\t\tlet dropStatus = self.getDropStatus()\n\t\t\tif self.uniqueAuction.auctionID == auctionId {\n\t\t\t\treturn &self.uniqueAuction as &Auction.AuctionItem\n\t\t\t} else {\n\t\t\t\tlet editionStatus=dropStatus.editionsStatuses[auctionId]!\n\t\t\t\treturn &self.editionAuctions.auctionItems[auctionId] as &Auction.AuctionItem\n\t\t\t}\n\t\t}\n\n\t\tpub fun currentBidForUser( auctionId: UInt64, address:Address) : UFix64 {\n\n\t\t\tlet auction=self.getAuction(auctionId:auctionId)\n\t\t\treturn auction.currentBidForUser(address: address)\n\n\t\t}\n\n\t\t//place a bid on a given auction\n\t\tpub fun placeBid( auctionId:UInt64, bidTokens: @FungibleToken.Vault, vaultCap: Capability<&{FungibleToken.Receiver}>, collectionCap: Capability<&{Art.CollectionPublic}>) {\n\n\t\t\tpre {\n\t\t\t\tcollectionCap.check() == true : \"Collection capability must be linked\"\n\t\t\t\tvaultCap.check() == true : \"Vault capability must be linked\"\n\t\t\t}\n\n\t\t\tlet dropStatus = self.getDropStatus()\n\t\t\tvar editionPrice=dropStatus.editionPrice\n\t\t\tvar uniquePrice=dropStatus.uniquePrice\n\t\t\tlet block=getCurrentBlock()\n\t\t\tlet time=Fix64(block.timestamp)\n\n\t\t\tif dropStatus.startTime > time {\n\t\t\t\tpanic(\"The drop has not started\")\n\t\t\t}\n\n\t\t\tif dropStatus.endTime < time && dropStatus.winning != \"TIE\" {\n\t\t\t\tpanic(\"This drop has ended\")\n\t\t\t}\n\n\t\t\tlet bidEndTime = time + Fix64(self.extensionOnLateBid)\n\n\t\t\t//we save the time of the first bid so that it can be used to fetch events from that given block\n\t\t\tif self.firstBidBlock == nil {\n\t\t\t\tself.firstBidBlock=block.height\n\t\t\t}\n\n\t\t\tvar endTime=dropStatus.endTime\n\t\t\tvar extendWith=(0.0 as Fix64)\n\n\t\t\t//We need to extend the auction since there is too little time left. If we did not do this a late user could potentially win with a cheecky bid\n\t\t\tif dropStatus.endTime < bidEndTime {\n\t\t\t\t extendWith=bidEndTime - dropStatus.endTime\n\t\t\t\tendTime=bidEndTime\n\t\t\t\temit DropExtended(name: dropStatus.metadata.name, artist: dropStatus.metadata.artist, dropId:self.dropID, extendWith: extendWith, extendTo: bidEndTime)\n\t\t\t\tself.extendDropWith(UFix64(extendWith))\n\t\t\t}\n\n\t\t\tlet bidder=vaultCap.address\n\t\t\tlet currentBidForUser= self.currentBidForUser(auctionId: auctionId, address: bidder)\n\t\t\tlet bidPrice = bidTokens.balance + currentBidForUser\n\n\t\t\tvar edition:String=\"1 of 1\"\n\n\n\t\t\tvar oldBidder : Address?=nil\n\t\t\tvar oldPrice: UFix64?=nil\n\t\t\t//the bid is on a unique auction so we place the bid there\n\t\t\tif self.uniqueAuction.auctionID == auctionId {\n\t\t\t\tlet auctionRef = &self.uniqueAuction as &Auction.AuctionItem\n\t\t\t\toldBidder=dropStatus.uniqueStatus.leader\n\t\t\t\toldPrice=dropStatus.uniquePrice\n\t\t\t\tuniquePrice=bidPrice\n\t\t\t\tauctionRef.placeBid(bidTokens: <- bidTokens, vaultCap:vaultCap, collectionCap:collectionCap)\n\t\t\t} else {\n\t\t\t\teditionPrice=editionPrice+bidTokens.balance\n\t\t\t\tlet editionStatus=dropStatus.editionsStatuses[auctionId]!\n\t\t\t\toldBidder=editionStatus.leader\n\t\t\t\toldPrice=editionStatus.price\n\t\t\t\tedition=editionStatus.edition.toString().concat( \" of \").concat(editionStatus.maxEdition.toString())\n\t\t\t\tlet editionsRef = &self.editionAuctions as &Auction.AuctionCollection\n\t\t\t\teditionsRef.placeBid(id: auctionId, bidTokens: <- bidTokens, vaultCap:vaultCap, collectionCap:collectionCap)\n\t\t\t}\n\n\t\t\temit Bid(name: dropStatus.metadata.name, artist:dropStatus.metadata.artist, edition: edition, bidder:bidder, price:bidPrice, dropId:self.dropID, auctionId:auctionId)\n\n\t\t\tlet newStatus=self.calculateStatus(edition:editionPrice, unique: uniquePrice)\n\n\t\t\tif dropStatus.winning != newStatus {\n\t\t\t\temit LeaderChanged(name:dropStatus.metadata.name, artist: dropStatus.metadata.artist, winning:newStatus, dropId: self.dropID)\n\t\t\t}\n\n\n\t\t\tvar bidderName=\"\"\n\t\t\tlet bidderProfileCap= getAccount(bidder).getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\t\tif bidderProfileCap.check() {\n\t\t\t\tbidderName=bidderProfileCap.borrow()!.getName()\n\t\t\t}\n\n\t\t\tvar oldBidderName=\"\"\n\t\t\tif oldBidder != nil {\n\t\t\t\tif oldBidder == bidder {\n\t\t\t\t\toldBidderName=bidderName\n\t\t\t\t} else{\n\t\t\t\t\tlet oldBidderProfileCap= getAccount(oldBidder!).getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\t\t\t\tif oldBidderProfileCap.check() {\n\t\t\t\t\t oldBidderName=oldBidderProfileCap.borrow()!.getName()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\temit ExtendedBid(name: dropStatus.metadata.name, artist:dropStatus.metadata.artist, edition: edition, bidderAddress:bidder, bidderName: bidderName, price:bidPrice, oldBidderAddress: oldBidder, oldBidderName: oldBidderName, oldPrice: oldPrice, dropId:self.dropID, auctionId:auctionId, auctionEndAt: endTime, extendWith: extendWith, cacheKey: self.contentId.toString(), oldLeader: dropStatus.winning, newLeader: newStatus)\n\t\t}\n\n\t\t//This would make it possible to extend the drop with more time from an admin interface\n\t\t//here we just delegate to the auctions and extend them all\n\t\tpub fun extendDropWith(_ time: UFix64) {\n\t\t\tlog(\"Drop extended with duration\")\n\t\t\tself.uniqueAuction.extendWith(time)\n\t\t\tself.editionAuctions.extendAllAuctionsWith(time)\n\t\t}\n\n\t}\n\n\n\t//this is a simpler version of the Acution status since we do not need to duplicate all the fields\n\t//edition and maxEidtion will not be kept here after the auction has been settled.\n\t//Really not sure on how to handle showing historic drops so for now I will just leave it as it is\n\tpub struct DropAuctionStatus {\n\t\tpub let id: UInt64\n\t\tpub let price : UFix64\n\t\tpub let bidIncrement : UFix64\n\t\tpub let bids : UInt64\n\t\tpub let edition: UInt64\n\t\tpub let maxEdition: UInt64\n\t\tpub let leader: Address?\n\t\tpub let minNextBid: UFix64\n\t\tinit(_ auctionStatus: Auction.AuctionStatus) {\n\t\t\tself.price=auctionStatus.price\n\t\t\tself.bidIncrement=auctionStatus.bidIncrement\n\t\t\tself.bids=auctionStatus.bids\n\t\t\tself.edition=auctionStatus.metadata?.edition  ?? (0 as UInt64)\n\t\t\tself.maxEdition=auctionStatus.metadata?.maxEdition ?? (0 as UInt64)\n\t\t\tself.leader=auctionStatus.leader\n\t\t\tself.minNextBid=auctionStatus.minNextBid\n\t\t\tself.id=auctionStatus.id\n\t\t}\n\t}\n\n\t//The struct that holds status information of a drop.\n\t//this probably has some duplicated data that could go away. like do you need both a settled and settledAt? and active?\n\tpub struct DropStatus {\n\t\tpub let dropId: UInt64\n\t\tpub let uniquePrice: UFix64\n\t\tpub let editionPrice: UFix64\n\t\tpub let difference: UFix64\n\t\tpub let endTime: Fix64\n\t\tpub let startTime: Fix64\n\t\tpub let uniqueStatus: DropAuctionStatus\n\t\tpub let editionsStatuses: {UInt64: DropAuctionStatus}\n\t\tpub let winning: String\n\t\tpub let active: Bool\n\t\tpub let timeRemaining: Fix64\n\t\tpub let firstBidBlock:UInt64?\n\t\tpub let metadata: Art.Metadata\n\t\tpub let expired: Bool\n\t\tpub let settledAt: UInt64?\n\t\tpub let startPrice: UFix64\n\n\t\tinit(\n\t\t\tdropId: UInt64,\n\t\t\tuniqueStatus: Auction.AuctionStatus,\n\t\t\teditionsStatuses: {UInt64: DropAuctionStatus},\n\t\t\teditionPrice: UFix64,\n\t\t\tstatus: String,\n\t\t\tfirstBidBlock:UInt64?,\n\t\t\tdifference:UFix64,\n\t\t\tmetadata: Art.Metadata,\n\t\t\tsettledAt: UInt64?\n\t\t\tactive: Bool\n\t\t\tstartPrice: UFix64\n\t\t) {\n\t\t\tself.dropId=dropId\n\t\t\tself.uniqueStatus=DropAuctionStatus(uniqueStatus)\n\t\t\tself.editionsStatuses=editionsStatuses\n\t\t\tself.uniquePrice= uniqueStatus.price\n\t\t\tself.editionPrice= editionPrice\n\t\t\tself.endTime=uniqueStatus.endTime\n\t\t\tself.startTime=uniqueStatus.startTime\n\t\t\tself.timeRemaining=uniqueStatus.timeRemaining\n\t\t\tself.active= active\n\t\t\tself.winning=status\n\t\t\tself.firstBidBlock=firstBidBlock\n\t\t\tself.difference=difference\n\t\t\tself.metadata=metadata\n\t\t\tself.expired=uniqueStatus.expired\n\t\t\tself.settledAt=settledAt\n\t\t\tself.startPrice =startPrice\n\t\t}\n\t}\n\n\t//An resource interface that everybody can access through a public capability.\n\tpub resource interface PublicDrop {\n\n\t\tpub fun currentBidForUser(dropId: UInt64, auctionId: UInt64, address:Address) : UFix64\n\t\tpub fun getAllStatuses(): {UInt64: DropStatus}\n\t\tpub fun getCacheKeyForDrop(_ dropId: UInt64) : UInt64\n\t\tpub fun getStatus(dropId: UInt64): DropStatus\n\n\t\tpub fun getArt(dropId: UInt64): String\n\n\t\tpub fun placeBid(dropId: UInt64, auctionId:UInt64, bidTokens: @FungibleToken.Vault, vaultCap: Capability<&{FungibleToken.Receiver}>, collectionCap: Capability<&{Art.CollectionPublic}>)\n\t}\n\n\tpub resource interface AdminDrop {\n\n\t\tpub fun createDrop(nft: @NonFungibleToken.NFT, editions: UInt64, minimumBidIncrement: UFix64, minimumBidUniqueIncrement: UFix64, startTime: UFix64, startPrice: UFix64, vaultCap: Capability<&{FungibleToken.Receiver}>, duration: UFix64, extensionOnLateBid:UFix64)\n\n\t\tpub fun settle(_ dropId: UInt64)\n\n\t}\n\n\tpub resource DropCollection: PublicDrop, AdminDrop {\n\n\t\taccess(account) var drops: @{UInt64: Drop}\n\n\t\t//it is possible to adjust the cutPercentage if you own a Versus.DropCollection\n\t\taccess(account) var cutPercentage:UFix64\n\n\t\taccess(account) let marketplaceVault: Capability<&{FungibleToken.Receiver}>\n\n\t\t//NFTs that are not sold are put here when a bid is settled.\n\t\taccess(account) let marketplaceNFTTrash: Capability<&{Art.CollectionPublic}>\n\n\t\tinit( marketplaceVault: Capability<&{FungibleToken.Receiver}>, marketplaceNFTTrash: Capability<&{Art.CollectionPublic}>, cutPercentage: UFix64) {\n\t\t\tself.marketplaceNFTTrash=marketplaceNFTTrash\n\t\t\tself.cutPercentage= cutPercentage\n\t\t\tself.marketplaceVault = marketplaceVault\n\t\t\tself.drops <- {}\n\t\t}\n\n\t\tpub fun withdraw(_ withdrawID: UInt64): @Drop {\n\t\t\tlet token <- self.drops.remove(key: withdrawID) ?? panic(\"missing drop\")\n\t\t\treturn <-token\n\t\t}\n\n\t\t/// Set the cut percentage for versus\n\n\t\t/// @param cut: The cut percentage as a Ufix64 that versus will take for each drop\n\t\tpub fun setCutPercentage(_ cut: UFix64) {\n\t\t\tself.cutPercentage=cut\n\t\t}\n\n\t\t// When creating a drop you send in an NFT and the number of editions you want to sell vs the unique one\n\t\t// There will then be minted edition number of extra copies and put into the editions auction\n\t\tpub fun createDrop( nft: @NonFungibleToken.NFT, editions: UInt64, minimumBidIncrement: UFix64, minimumBidUniqueIncrement: UFix64, startTime: UFix64, startPrice: UFix64, vaultCap: Capability<&{FungibleToken.Receiver}>, duration: UFix64,\n\t\t\textensionOnLateBid: UFix64) {\n\n\t\t\tpre {\n\t\t\t\tvaultCap.check() == true : \"Vault capability should exist\"\n\t\t\t}\n\n\t\t\tlet art <- nft as! @Art.NFT\n\n\t\t\tlet contentCapability= art.contentCapability!\n\t\t\tlet contentId= art.contentId!\n\n\t\t\tlet metadata= art.metadata\n\t\t\t//Sending in a NFTEditioner capability here and using that instead of this loop would probably make sense.\n\t\t\tlet editionedAuctions <- Auction.createAuctionCollection( marketplaceVault: self.marketplaceVault , cutPercentage: self.cutPercentage)\n\n\t\t\tvar currentEdition=(1 as UInt64)\n\t\t\twhile currentEdition <= editions {\n\t\t\t\t\teditionedAuctions.createAuction( token: <- Art.makeEdition(original: &art as &Art.NFT, edition: currentEdition, maxEdition: editions), minimumBidIncrement: minimumBidIncrement, auctionLength: duration, auctionStartTime:startTime, startPrice: startPrice, collectionCap: self.marketplaceNFTTrash, vaultCap: vaultCap)\n\t\t\t\t\tcurrentEdition=currentEdition+(1 as UInt64)\n\t\t\t}\n\n\t\t\t//copy the metadata of the previous art since that is used to mint the copies\n\t\t\tlet item <- Auction.createStandaloneAuction( token: <- art, minimumBidIncrement: minimumBidUniqueIncrement, auctionLength: duration, auctionStartTime: startTime, startPrice: startPrice, collectionCap: self.marketplaceNFTTrash, vaultCap: vaultCap)\n\n\t\t\tlet drop  <- create Drop( uniqueAuction: <- item, editionAuctions:  <- editionedAuctions, extensionOnLateBid: extensionOnLateBid, contentId: contentId, contentCapability: contentCapability)\n\t\t\temit DropCreated(name: metadata.name, artist: metadata.artist,  editions: editions, owner: vaultCap.address, dropId: drop.dropID)\n\n\t\t\tlet oldDrop <- self.drops[drop.dropID] <- drop\n\t\t\tdestroy oldDrop\n\t\t}\n\n  \t//Get all the drop statuses\n  \tpub fun getAllStatuses(): {UInt64: DropStatus} {\n  \t\tvar dropStatus: {UInt64: DropStatus }= {}\n  \t\tfor id in self.drops.keys {\n  \t\t\tlet itemRef = &self.drops[id] as? &Drop\n  \t\t\tdropStatus[id] = itemRef.getDropStatus()\n  \t\t}\n  \t\treturn dropStatus\n  \t}\n\n  \taccess(contract) fun getDrop(_ dropId:UInt64) : &Drop {\n  \t\tpre {\n  \t\t\tself.drops[dropId] != nil:\n  \t\t\t\"drop doesn't exist\"\n  \t\t}\n  \t\treturn &self.drops[dropId] as &Drop\n  \t}\n\n\t\tpub fun getDropByCacheKey(_ cacheKey: UInt64) : DropStatus? {\n\t\t\tvar dropStatus: {UInt64: DropStatus }= {}\n\t\t\tfor id in self.drops.keys {\n\t\t\t\tlet itemRef = &self.drops[id] as? &Drop\n\t\t\t\tif itemRef.contentId == cacheKey {\n\t\t\t\t\treturn itemRef.getDropStatus()\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tpub fun getCacheKeyForDrop(_ dropId: UInt64) : UInt64 {\n\t\t\treturn self.getDrop(dropId).contentId\n\t\t}\n\n\t\tpub fun getStatus(dropId:UInt64): DropStatus {\n\t\t\treturn self.getDrop(dropId).getDropStatus()\n\t\t}\n\n\t\t//get the art for this drop\n\t\tpub fun getArt(dropId:UInt64) : String {\n\t\t\treturn self.getDrop(dropId).getContent()\n\t\t}\n\n\t\tpub fun getArtType(dropId:UInt64): String {\n\t\t\treturn self.getDrop(dropId).metadata.type\n\t\t}\n\n\t\t//settle a drop\n\t\tpub fun settle(_ dropId: UInt64) {\n\t\t\tself.getDrop(dropId).settle(cutPercentage: self.cutPercentage, vault: self.marketplaceVault)\n\t\t}\n\t\t\n\t\tpub fun currentBidForUser( dropId: UInt64, auctionId: UInt64, address:Address) : UFix64 {\n\t\t\treturn  self.getDrop(dropId).currentBidForUser(\n\t\t\t\tauctionId: auctionId,\n\t\t\t\taddress:address\n\t\t\t)\n\t\t}\n\n\t\t//place a bid, will just delegate to the method in the drop collection\n\t\tpub fun placeBid(dropId: UInt64, auctionId:UInt64, bidTokens: @FungibleToken.Vault, vaultCap: Capability<&{FungibleToken.Receiver}>, collectionCap: Capability<&{Art.CollectionPublic}>) {\n\t\t\tself.getDrop(dropId).placeBid( auctionId: auctionId, bidTokens: <- bidTokens, vaultCap: vaultCap, collectionCap:collectionCap)\n\t\t}\n\n\t\tdestroy() {\n\t\t\tdestroy self.drops\n\t\t}\n\t}\n\n\t// Get the art stored on chain for this drop\n\tpub fun getArtForDrop(_ dropId: UInt64) : String? {\n\t\tlet versusCap=Versus.account.getCapability<&{Versus.PublicDrop}>(self.CollectionPublicPath)\n\t\tif let versus = versusCap.borrow()  {\n\t\t\treturn versus.getArt(dropId: dropId)\n\t\t}\n\t\treturn nil\n\t}\n\n\t/*\n\tGet an active drop in the versus marketplace\n\n\t*/\n\tpub fun getDrops() : [Versus.DropStatus]{\n\t\tlet account = Versus.account\n\t\tlet versusCap=account.getCapability<&{Versus.PublicDrop}>(self.CollectionPublicPath)!\n\t\treturn versusCap.borrow()!.getAllStatuses().values\n\t}\n\n\tpub fun getDrop(_ id: UInt64) : Versus.DropStatus? {\n\t\tlet account = Versus.account\n\t\tlet versusCap=account.getCapability<&{Versus.PublicDrop}>(Versus.CollectionPublicPath)\n\t\tif let versus = versusCap.borrow() {\n\t\t\treturn versus.getStatus(dropId: id)\n\t\t}\n\t\treturn nil\n\t}\n\n\t/*\n\tGet the first active drop in the versus marketplace\n\t*/\n\tpub fun getActiveDrop() : Versus.DropStatus?{\n\t\t// get the accounts' public address objects\n\t\tlet account = Versus.account\n\n\t\tlet versusCap=account.getCapability<&{Versus.PublicDrop}>(self.CollectionPublicPath)\n\t\tif let versus = versusCap.borrow() {\n\t\t\tlet versusStatuses=versus.getAllStatuses()\n\t\t\tfor s in versusStatuses.keys {\n\t\t\t\tlet status = versusStatuses[s]!\n\t\t\t\tif status.active != false {\n\t\t\t\t\treturn status\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\n\n\t//The interface used to add a Versus Drop Collection capability to a AdminPublic\n\tpub resource interface AdminPublic {\n\t\tpub fun addCapability(_ cap: Capability<&Versus.DropCollection>)\n\t}\n\n\t//The versus admin resource that a client will create and store, then link up a public AdminPublic\n\tpub resource Admin: AdminPublic {\n\n\t\taccess(self) var server: Capability<&Versus.DropCollection>?\n\n\t\tinit() {\n\t\t\tself.server = nil\n\t\t}\n\n\t\tpub fun addCapability(_ cap: Capability<&Versus.DropCollection>) {\n\t\t\tpre {\n\t\t\t\tcap.check() : \"Invalid server capablity\"\n\t\t\t\tself.server == nil : \"Server already set\"\n\t\t\t}\n\t\t\tself.server = cap\n\t\t}\n\n\t\t// This will settle/end an auction\n\t\tpub fun settle(_ dropId: UInt64) {\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\t\t\tself.server!.borrow()!.settle(dropId)\n\n\t\t\t//since settling will return all items not sold to the NFTTrash, we take out the trash here.\n\t\t\tlet artC=Versus.account.borrow<&NonFungibleToken.Collection>(from: Art.CollectionStoragePath)!\n\t\t\tfor key in artC.ownedNFTs.keys{\n\t\t\t\tlog(\"burning art with key=\".concat(key.toString()))\n\t\t\t\tdestroy <- artC.ownedNFTs.remove(key: key)\n\t\t\t}\n\t\t}\n\n\t\tpub fun setVersusCut(_ num:UFix64) {\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\n\t\t\tlet dc:&Versus.DropCollection=self.server!.borrow()!\n\t\t\tdc.setCutPercentage(num)\n\t\t}\n\n\t\tpub fun createDrop(\n\t\t\tnft: @NonFungibleToken.NFT,\n\t\t\teditions: UInt64,\n\t\t\tminimumBidIncrement: UFix64,\n\t\t\tminimumBidUniqueIncrement: UFix64,\n\t\t\tstartTime: UFix64,\n\t\t\tstartPrice: UFix64,  //TODO: seperate startPrice for unique and edition\n\t\t\tvaultCap: Capability<&{FungibleToken.Receiver}>\n\t\t\tduration: UFix64,\n\t\t\textensionOnLateBid: UFix64)  {\n\n\t\t\t\tpre {\n\t\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t\t}\n\n\t\t\t\tself.server!.borrow()!.createDrop(nft: <- nft,\n\t\t\t\teditions:editions,\n\t\t\t\tminimumBidIncrement:minimumBidIncrement,\n\t\t\t\tminimumBidUniqueIncrement:minimumBidUniqueIncrement,\n\t\t\t\tstartTime:startTime,\n\t\t\t\tstartPrice:startPrice,\n\t\t\t\tvaultCap:vaultCap,\n\t\t\t\tduration: duration,\n\t\t\t\textensionOnLateBid: extensionOnLateBid\n\t\t\t)\n\t\t}\n\n\t\t/* A stored Transaction to mintArt on versus to a given artist */\n\t\tpub fun mintArt(artist: Address, artistName: String, artName: String, content:String, description: String, type:String, artistCut: UFix64, minterCut:UFix64) : @Art.NFT{\n\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\n\t\t\tlet artistAccount = getAccount(artist)\n\t\t\tvar contentItem  <- Content.createContent(content)\n\t\t\tlet contentId= contentItem.id\n\t\t\tlet contentCapability=Versus.account.getCapability<&Content.Collection>(Content.CollectionPrivatePath)\n\t\t\tcontentCapability.borrow()!.deposit(token: <- contentItem)\n\n\t\t\tlet artistWallet= artistAccount.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\t\t\tlet minterWallet= Versus.account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\n\t\t\tlet royalty = {\n\t\t\t\t\"artist\" : Art.Royalty(wallet: artistWallet, cut: artistCut),\n\t\t\t\t\"minter\" : Art.Royalty(wallet: minterWallet, cut: minterCut)\n\t\t\t}\n\t\t\tlet art <- Art.createArtWithPointer(name: artName, artist:artistName, artistAddress : artist, description: description, type: type, contentCapability: contentCapability, contentId: contentId, royalty: royalty)\n\t\t\treturn <- art\n\t\t}\n\n\n\t\tpub fun editionArt(art: &Art.NFT, edition: UInt64, maxEdition: UInt64) : @Art.NFT {\n\t\t\treturn <- Art.makeEdition(original: art, edition: edition, maxEdition: maxEdition)\n\t\t}\n\n\t\tpub fun editionAndDepositArt(art: &Art.NFT, to: [Address]) {\n\n\t\t\tlet maxEdition:UInt64=UInt64(to.length)\n\n\t\t\tvar i:UInt64=1\n\n\t\t\tfor address in to {\n\t\t\t\tlet editionedArt <- Art.makeEdition(original: art, edition: i, maxEdition: maxEdition)\n\t\t\t\tlet account= getAccount(address)\n\t\t\t\tvar collectionCap = account.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n\t\t\t\tcollectionCap.borrow()!.deposit(token: <- editionedArt)\n\t\t\t\ti=i+(1 as UInt64)\n\t\t\t}\n\t\t}\n\n\t\tpub fun getContent():&Content.Collection {\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\t\t\treturn Versus.account.borrow<&Content.Collection>(from: Content.CollectionStoragePath)!\n\t\t}\n\n\t\tpub fun getFlowWallet():&FungibleToken.Vault {\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\t\t\treturn Versus.account.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault)!\n\t\t}\n\n\t\tpub fun getArtCollection() : &NonFungibleToken.Collection {\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\t\t\treturn Versus.account.borrow<&NonFungibleToken.Collection>(from: Art.CollectionStoragePath)!\n\t\t}\n\n\t\tpub fun getDropCollection(): &Versus.DropCollection {\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\t\t\treturn self.server!.borrow()!\n\t\t}\n\n\t\tpub fun getVersusProfile(): &Profile.User {\n\t\t\tpre {\n\t\t\t\tself.server != nil : \"Your client has not been linked to the server\"\n\t\t\t}\n\t\t\treturn Versus.account.borrow<&Profile.User>(from: Profile.storagePath)!\n\t\t}\n\n\t}\n\n\t//make it possible for a user that wants to be a versus admin to create the client\n\tpub fun createAdminClient(): @Admin {\n\t\treturn <- create Admin()\n\t}\n\n\t//initialize all the paths and create and link up the admin proxy\n\t//init is only executed on initial deployment\n\tinit() {\n\n\t\tself.CollectionPublicPath= /public/versusCollection\n\t\tself.CollectionPrivatePath= /private/versusCollection\n\t\tself.CollectionStoragePath= /storage/versusCollection\n\t\tself.VersusAdminPublicPath= /public/versusAdmin\n\t\tself.VersusAdminStoragePath=/storage/versusAdmin\n\n\t\tself.totalDrops = (0 as UInt64)\n\n\t\tlet account=self.account\n\n\t\tlet marketplaceReceiver=account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\t\tlet marketplaceNFTTrash: Capability<&{Art.CollectionPublic}> =account.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n\n\t\tlog(\"Setting up versus capability\")\n\t\tlet collection <- create DropCollection(\n\t\t\tmarketplaceVault: marketplaceReceiver,\n\t\t\tmarketplaceNFTTrash: marketplaceNFTTrash,\n\t\t\tcutPercentage: 0.15\n\t\t)\n\t\taccount.save(<-collection, to: Versus.CollectionStoragePath)\n\t\taccount.link<&{Versus.PublicDrop}>(Versus.CollectionPublicPath, target: Versus.CollectionStoragePath)\n\t\taccount.link<&Versus.DropCollection>(Versus.CollectionPrivatePath, target: Versus.CollectionStoragePath)\n\t}\n\n}\n"},{"address":"0x3558f4548a40dc77","contractName":"ArtistRegistery","code":"/**\n# ArtistRegistery contract\n\nThis contract, owned by the platform admin, allows to define the artists metadata and vaults to receive their cut. \n\n */\n\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\naccess(all) contract ArtistRegistery {\n\n    // -----------------------------------------------------------------------\n    // Variables \n    // -----------------------------------------------------------------------\n    // Manager public path, allowing an Admin to initialize it\n    pub let ManagerPublicPath: PublicPath\n    // Manager storage path, for a manager to manager an artist\n    pub let ManagerStoragePath: StoragePath\n    // Admin storage path\n    pub let AdminStoragePath: StoragePath\n    // Admin private path, allowing initialized Manager to cmanage an artist\n    pub let AdminPrivatePath: PrivatePath\n\n    access(self) var artists: @{UInt64: Artist}\n    access(self) var artistTempVaults: @{UInt64: FUSD.Vault} // temporary vaults when the artists' ones are not available\n    pub var numberOfArtists: UInt64 \n\n    // -----------------------------------------------------------------------\n    // Events \n    // -----------------------------------------------------------------------\n    \n    // An artist has been created\n    pub event Created(id: UInt64, name: String)\n    // An artist has received FUSD\n    pub event FUSDReceived(id: UInt64, amount: UFix64)\n    // An artist vault has been updated\n    pub event VaultUpdated(id: UInt64)\n    // An artist name has been updated\n    pub event NameUpdated(id: UInt64, name: String)\n\n    // -----------------------------------------------------------------------\n    // Resources \n    // -----------------------------------------------------------------------\n\n    // Resource representing a single artist\n    pub resource Artist {\n        pub let id: UInt64\n        pub var name: String\n        access(self) var vault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n\n        init(name: String) {\n            ArtistRegistery.numberOfArtists = ArtistRegistery.numberOfArtists + (1 as UInt64)\n            self.id = ArtistRegistery.numberOfArtists\n\n            self.name = name\n            self.vault = nil\n\n            emit Created(id: self.id, name: name)\n        }\n\n        // Update the artist name\n        access(contract) fun updateName(name: String) {\n            self.name = name\n            emit NameUpdated(id: self.id, name: name)\n        }\n\n        // Update the artist vault to receive their cut from sales and auctions\n        access(contract) fun updateVault(vault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            self.vault = vault\n            emit VaultUpdated(id: self.id)\n        }\n\n        // Send the artist share. If the artist vault is not available, it is put in a temporary vault\n        pub fun sendShare(deposit: @FungibleToken.Vault) {\n            let balance = deposit.balance \n            if(self.vault != nil && self.vault!.check()) {\n                let vaultRef = self.vault!.borrow()!\n                vaultRef.deposit(from: <-deposit)\n            }\n            else {\n                // If the artist vault is anavailable, put the tokens in a temporary vault\n                let artistTempVault = &ArtistRegistery.artistTempVaults[self.id] as &FUSD.Vault\n                artistTempVault.deposit(from: <-deposit) // will fail if it is not a @FUSD.Vault\n            }\n\n            emit FUSDReceived(id: self.id, amount: balance)\n        }\n\n        // When an artist vault is not available, the tokens are put in a temporary vault\n        // This function allows to release the funds to the artist's newly set vault\n        pub fun unlockArtistShare() {\n            let artistTempVault = &ArtistRegistery.artistTempVaults[self.id] as &FUSD.Vault\n            if(self.vault != nil && self.vault!.check()) {\n                let vaultRef = self.vault!.borrow()!\n                vaultRef.deposit(from: <-artistTempVault.withdraw(amount: artistTempVault.balance))\n            } \n            else {\n                panic(\"Cannot borrow artist's vault\")\n            }\n        }\n    }\n\n    // ArtistModifier\n    //\n    // An artist modifier can update the artist info\n    //\n    pub resource interface ArtistModifier {\n        // Update an artist's name\n        pub fun updateName(id: UInt64, name: String) \n\n        // Update an artist's vault\n        pub fun updateVault(id: UInt64, vault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) \n\n        // When an artist vault is not available, the tokens are put in a temporary vault\n        // This function allows to release the funds to the artist's newly set vault\n        pub fun unlockArtistShare(id: UInt64) \n\n    }\n\n    // An admin creates artists, allowing Sale and Auction contract to send the artist share\n    pub resource Admin: ArtistModifier {\n        // Create an artist\n        pub fun createArtist(name: String) {\n            let artist <- create Artist(name: name)\n\n            ArtistRegistery.artistTempVaults[artist.id] <-! FUSD.createEmptyVault() as! @FUSD.Vault\n            ArtistRegistery.artists[artist.id] <-! artist\n        }\n\n        // Update an artist's name\n        // If artist doesn't exist, will not fail, nothing will happen\n        pub fun updateName(id: UInt64, name: String) {\n            ArtistRegistery.artists[id]?.updateName(name: name)\n        }\n\n        // Update an artist's vault\n        // If artist doesn't exist, will not fail, nothing will happen\n        pub fun updateVault(id: UInt64, vault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            pre {\n                vault.check(): \"The artist vault should be available\"\n            }\n\n           ArtistRegistery.artists[id]?.updateVault(vault: vault)\n        }\n\n        // When an artist vault is not available, the tokens are put in a temporary vault\n        // This function allows to release the funds to the artist's newly set vault\n        // If artist doesn't exist, will not fail, nothing will happen\n        pub fun unlockArtistShare(id: UInt64) {\n            ArtistRegistery.artists[id]?.unlockArtistShare()\n        }\n    }\n    \n    pub resource interface ManagerClient {\n        pub fun setArtist(artistID: UInt64, server: Capability<&Admin{ArtistModifier}>)\n    }\n\n    // Manager\n    //\n    // A manager can change the artist vault and name\n    //\n    pub resource Manager: ManagerClient {\n        access(self) var artistID: UInt64?\n        access(self) var server: Capability<&Admin{ArtistModifier}>?\n\n        init() {\n            self.artistID = nil \n            self.server = nil\n        }\n\n        pub fun setArtist(artistID: UInt64, server: Capability<&Admin{ArtistModifier}>) {\n            pre {\n                server.check() : \"Invalid server capablity\"\n                self.server == nil : \"Server already set\"\n                self.artistID == nil : \"Artist already set\"\n            }\n            self.server = server\n            self.artistID = artistID\n        }\n\n        // Update an artist's name\n        pub fun updateName(name: String) {\n            pre {\n                self.server != nil : \"Server not set\"\n                self.artistID != nil : \"Artist not set\"\n            }\n            if let artistModifier = self.server!.borrow() {\n                artistModifier.updateName(id: self.artistID!, name: name)\n                return \n            }\n            panic(\"Could not borrow the artist modifier\")\n        }\n\n        // Update an artist's vault\n        pub fun updateVault(vault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            pre {\n                self.server != nil : \"Server not set\"\n                self.artistID != nil : \"Artist not set\"\n            }\n            if let artistModifier = self.server!.borrow() {\n                artistModifier.updateVault(id: self.artistID!, vault: vault)\n                return\n            }\n            panic(\"Could not borrow the artist modifier\")\n        }\n\n        // When an artist vault is not available, the tokens are put in a temporary vault\n        // This function allows to release the funds to the artist's newly set vault\n        pub fun unlockArtistShare() {\n            pre {\n                self.server != nil : \"Server not set\"\n                self.artistID != nil : \"Artist not set\"\n            }\n            if let artistModifier = self.server!.borrow() {\n                artistModifier.unlockArtistShare(id: self.artistID!)\n                return\n            }\n            panic(\"Could not borrow the artist modifier\")\n        }\n    }\n    \n\n    // -----------------------------------------------------------------------\n    // Contract public functions\n    // -----------------------------------------------------------------------\n\n    pub fun createManager(): @Manager {\n        return <- create Manager()\n    }\n\n    // Send the artist share. If the artist vault is not available, it is put in a temporary vault\n    pub fun sendArtistShare(id: UInt64, deposit: @FungibleToken.Vault) {\n        pre {\n            ArtistRegistery.artists[id] != nil: \"No such artist\"\n        }\n        let artist = &ArtistRegistery.artists[id] as &Artist\n        artist.sendShare(deposit: <-deposit)\n    }\n\n    // Get an artist's data (name, vault capability)\n    pub fun getArtistName(id: UInt64): String {\n        pre {\n            ArtistRegistery.artists[id] != nil: \"No such artist\"\n        }\n        let artist = &ArtistRegistery.artists[id] as &Artist\n        return artist.name\n    }\n\n\n            \n    // -----------------------------------------------------------------------\n    // Initialization function\n    // -----------------------------------------------------------------------\n\n    init() {\n        self.ManagerPublicPath = /public/boulangerieV1artistRegisteryManager\n        self.ManagerStoragePath = /storage/boulangerieV1artistRegisteryManager\n        self.AdminStoragePath = /storage/boulangerieV1artistRegisteryAdmin\n        self.AdminPrivatePath = /private/boulangerieV1artistRegisteryAdmin\n\n        self.artists <- {}\n        self.artistTempVaults <- {}\n        self.numberOfArtists = 0\n\n        let admin <- create Admin()\n        self.account.save(<-admin, to: self.AdminStoragePath)\n        self.account.link<&Admin{ArtistModifier}>(self.AdminPrivatePath, target: self.AdminStoragePath)\n    }\n}\n"},{"address":"0x3558f4548a40dc77","contractName":"BaguetteAuction","code":"/** \n\n# BaguetteAuction contract\n\nThis contract defines the auction system of Baguette. \nThe auction contract acts as an escrow for both NFTs and fungible tokens involved in auctions.\nAuctions are centralized in AuctionCollection maintained by admins.  \n\n## Withdrawals and cancelations\n\nNeither can an auction be canceled nor bid withdrawn.\n\n## Auction ends\n\nWhen the auction has expired, the settle function can be called to transfer the funds and the record.\nThe settle function is public, since it is risk free (nothing can be changed anyway).\n\n## Create an auction\nAn Auction is created within an AuctionCollection. An AuctionCollection can be created in two ways:\n- by the contract Admin, who can choose the auction parameters. It is used for the primary sales of a record.\n- by a Manager who has been initialized by an Admin. The different parameters are fixed at creation by the Admin to the contract parameters at that time.\n\nThe second option is used for secondary sales.\n\nUsers can only create an auction by accepting an offer made on their NFT as the first bid.\n\n## TimeExtension\n\nAn auction is extended by `timeExtension` minutes if a new bid is placed less than `timeExtension` minutes before the end.\n*/\n\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Record from 0x3558f4548a40dc77\nimport ArtistRegistery from 0x3558f4548a40dc77\n\n\npub contract BaguetteAuction {\n\n    // -----------------------------------------------------------------------\n    // Variables \n    // -----------------------------------------------------------------------\n\n    // Resource paths\n    // Public path of an auction collection, allowing the place new bids and to access to public information\n    pub let CollectionPublicPath: PublicPath\n    // Public path of an auction collection, allowing to create new auctions\n    pub let CollectionPrivatePath: PrivatePath\n    // Storage path of an auction collection\n    pub let CollectionStoragePath: StoragePath\n    // Manager public path, allowing an Admin to initialize it\n    pub let ManagerPublicPath: PublicPath\n    // Manager storage path, for a manager to create auction collections\n    pub let ManagerStoragePath: StoragePath\n    // Admin private path, allowing initialized Manager to create collections while hidding other admin functions\n    pub let AdminPrivatePath: PrivatePath\n    // Admin storage path\n    pub let AdminStoragePath: StoragePath\n\n    // Default parameters for auctions\n    pub var parameters: AuctionParameters\n    access(self) var marketVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n    access(self) var lostFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n    access(self) var lostRCollection: Capability<&Record.Collection{Record.CollectionPublic}>?\n\n    // total number of auctions and collections ever created\n    pub var totalAuctions: UInt64\n    pub var totalCollections: UInt64\n\n    // -----------------------------------------------------------------------\n    // Events \n    // -----------------------------------------------------------------------\n\n    // A new auction has been created\n    pub event Created(auctionID: UInt64, admin: Address, status: AuctionStatus)\n    // A new bid has been placed\n    pub event NewBid(auctionID: UInt64, status: AuctionStatus)\n    // The auction has been settled\n    pub event Settled(auctionID: UInt64)\n    \n    // Market and Artist share\n    pub event MarketplaceEarned(auctionID: UInt64, amount: UFix64, owner: Address)\n    pub event ArtistEarned(auctionID: UInt64, amount: UFix64, artistID: UInt64)\n\n    // lost and found events\n    pub event FUSDLostAndFound(auctionID: UInt64, amount: UFix64, address: Address)\n    pub event RecordLostAndFound(auctionID: UInt64, recordID: UInt64, address: Address)\n\n    // -----------------------------------------------------------------------\n    // Resources \n    // -----------------------------------------------------------------------\n\n    // Structure representing auction parameters\n    pub struct AuctionParameters {\n        pub let artistCut: UFix64 // share of the artist for a sale\n        pub let marketCut: UFix64 // share of the marketplace for a sale\n        pub let bidIncrement: UFix64 // minimal increment between bids\n        pub let auctionLength: UFix64 // length of an auction (before any extension)\n        pub let auctionDelay: UFix64 // delay before the start of an auction\n        pub let timeExtension: UFix64 // extension when bid in the last `timeExtension` seconds\n\n        init(\n            artistCut: UFix64,\n            marketCut: UFix64,\n            bidIncrement: UFix64,\n            auctionLength: UFix64,\n            auctionDelay: UFix64,\n            timeExtension: UFix64\n        ) {\n            self.artistCut = artistCut\n            self.marketCut = marketCut\n            self.bidIncrement = bidIncrement\n            self.auctionLength = auctionLength\n            self.auctionDelay = auctionDelay\n            self.timeExtension = timeExtension\n        }\n    }\n\n    // This structure holds the main information about an auction\n    pub struct AuctionStatus {\n        pub let id: UInt64\n        pub let recordID: UInt64\n        pub let metadata: Record.Metadata\n        pub let owner: Address\n        pub let leader: Address?\n        pub let currentBid: UFix64?\n        pub let nextMinBid: UFix64\n        pub let numberOfBids: UInt64\n        pub let bidIncrement: UFix64\n        pub let startTime: Fix64\n        pub let endTime: Fix64\n        pub let timeExtension: UFix64\n        pub let expired: Bool // the auction is expired and should be settled\n        pub let timeRemaining: Fix64\n    \n        init(\n            id: UInt64,\n            recordID: UInt64, \n            metadata: Record.Metadata,\n            owner: Address,\n            leader: Address?, \n            currentBid: UFix64?,\n            nextMinBid: UFix64,\n            numberOfBids: UInt64,\n            bidIncrement: UFix64,\n            startTime: Fix64,\n            endTime: Fix64,\n            timeExtension: UFix64,\n            expired: Bool\n        ) {\n            self.id = id\n            self.recordID = recordID\n            self.metadata = metadata\n            self.owner = owner\n            self.leader = leader\n            self.currentBid = currentBid \n            self.nextMinBid = nextMinBid\n            self.numberOfBids = numberOfBids\n            self.bidIncrement = bidIncrement\n            self.startTime = startTime\n            self.endTime = endTime\n            self.timeExtension = timeExtension\n            if expired {\n                self.timeRemaining = 0.0\n            }\n            else {\n                self.timeRemaining = endTime - Fix64(getCurrentBlock().timestamp)\n            }\n            self.expired = expired\n        }\n    }\n\n    // Resource representing a unique Auction\n    // The item is an optional resource, as it can be sent to the owner/bidder once the auction is settled\n    // If the item is nil, the auction becomes invalid (it should be destroyed)\n    // It acts as an escrow for the NFT and the fungible tokens, and contains all the capabilities to send the FT and NFT.\n    pub resource Auction {\n        // The id of this individual auction\n        pub let auctionID: UInt64\n        // The record for auction\n        priv var item: @Record.NFT?\n        \n        // auction parameters\n        pub let parameters: AuctionParameters\n        \n        priv var numberOfBids: UInt64 // amount of bids which have been placed\n        priv var auctionStartTime: UFix64\n        priv var auctionEndTime: UFix64\n\n        // the auction has been settled and should be destroyed\n        priv var auctionCompleted: Bool\n\n        // Auction State\n        priv var startPrice: UFix64\n        priv var currentBid: UFix64\n\n        priv let escrow: @FUSD.Vault \n\n        //the capabilities pointing to the resource where you want the NFT and FT transfered to if you win this bid.\n        priv var ownerAddr: Address\n        priv var bidderAddr: Address?\n        priv var bidderFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n        priv var bidderRCollection: Capability<&Record.Collection{Record.CollectionPublic}>?\n        priv let ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>\n        priv let ownerRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n\n        init(\n            item: @Record.NFT,\n            parameters: AuctionParameters,\n            auctionStartTime: UFix64,\n            startPrice: UFix64, \n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            ownerRCollection: Capability<&Record.Collection{Record.CollectionPublic}>,\n        ) {\n            pre {\n                ownerFVault.check(): \"The fungible vault should be valid.\"\n                ownerRCollection.check(): \"The non fungible collection should be valid.\"\n                item.tradable(): \"The item cannot be traded due to its current locked mode: it is probably waiting for its decryption key.\" \n                startPrice>0.0: \"Starting price should be greater than 0\"\n            }\n\n            BaguetteAuction.totalAuctions = BaguetteAuction.totalAuctions + (1 as UInt64)\n            self.auctionID = BaguetteAuction.totalAuctions\n\n            self.item <- item\n                        \n            self.startPrice = startPrice\n            self.currentBid = 0.0\n            self.parameters = parameters\n            self.numberOfBids = 0\n            \n            self.auctionStartTime = auctionStartTime\n            self.auctionEndTime = auctionStartTime + parameters.auctionLength\n            self.auctionCompleted = false\n\n            self.escrow <- FUSD.createEmptyVault()\n            self.bidderAddr = nil\n            self.bidderFVault = nil\n            self.bidderRCollection = nil\n            self.ownerAddr = ownerFVault.address\n            self.ownerFVault = ownerFVault\n            self.ownerRCollection = ownerRCollection\n        }\n        \n        // sendNFT sends the NFT to the Collection belonging to the provided Capability or to the lost and found if the capability is broken\n        // if both the receiver collection and lost and found are unlinked, the record is destroyed in the `destroy` function of this Auction\n        access(self) fun sendNFT(_ capability: Capability<&Record.Collection{Record.CollectionPublic}>) {\n            if let collectionRef = capability.borrow() {\n                let item <- self.item <- nil\n                \n                collectionRef.deposit(token: <-item!)\n                return\n            } \n            else if let collectionRef = BaguetteAuction.lostRCollection!.borrow() {\n                let item <- self.item <- nil\n                let recordID = item?.id!\n                \n                collectionRef.deposit(token: <-item!)\n                emit RecordLostAndFound(auctionID: self.auctionID, recordID: recordID, address: collectionRef.owner!.address)\n                return\n            }\n        }\n\n        // sendBidTokens sends the bid tokens to the Vault Receiver belonging to the provided Capability or to the lost and found if the capability is broken\n        access(self) fun sendBidTokens(_ capability: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            if let vaultRef = capability.borrow() {\n                if self.escrow.balance > 0.0 { \n                    vaultRef.deposit(from: <-self.escrow.withdraw(amount: self.escrow.balance))\n                }\n                return\n            }\n            else if let vaultRef = BaguetteAuction.lostFVault!.borrow() {\n                let balance = self.escrow.balance\n                if balance > 0.0 { \n                    vaultRef.deposit(from: <-self.escrow.withdraw(amount: balance))\n                }\n\n                emit FUSDLostAndFound(auctionID: self.auctionID, amount: balance, address: vaultRef.owner!.address)\n                return\n            }\n        }\n\n        // Send the previous bid back to the last bidder\n        access(self) fun releasePreviousBid() {\n            if let vaultCap = self.bidderFVault {\n                self.sendBidTokens(vaultCap)\n                return\n            } \n        }\n\n        // Return the NFT to the owner if no bid has been placed\n        access(self) fun retToOwner() {\n            // deposit the NFT into the owner's collection\n            self.sendNFT(self.ownerRCollection)\n        }\n\n        // Extend the auction by the amount of seconds\n        access(self) fun extendWith(_ amount: UFix64) {\n            self.auctionEndTime = self.auctionEndTime + amount\n        }\n\n        // get the remaning time can be negative if it's expired\n        pub fun timeRemaining() : Fix64 {\n            let currentTime = getCurrentBlock().timestamp\n            let remaining= Fix64(self.auctionEndTime) - Fix64(currentTime)\n            return remaining\n        }\n\n        // Has the auction expired?\n        pub fun isAuctionExpired(): Bool {\n            let timeRemaining = self.timeRemaining()\n            return timeRemaining < Fix64(0.0)\n        }\n\n        // Has the auction been settled\n        pub fun isAuctionCompleted(): Bool {\n            return self.auctionCompleted\n        }\n\n        // What the next bid has to match\n        pub fun minNextBid() :UFix64{\n            //If there are bids then the next min bid is the current price plus the increment\n            if self.currentBid != 0.0 {\n                return self.currentBid + self.parameters.bidIncrement\n            }\n            //else start price\n            return self.startPrice\n        }\n\n        // Settle the auction once it's expired. \n        pub fun settleAuction()  {\n            pre {\n                !self.auctionCompleted: \"The auction is already settled\" // cannot be settled twice\n                self.item != nil: \"Record in auction does not exist\" \n                self.isAuctionExpired(): \"Auction has not completed yet\" \n            }\n               \n            // return if there are no bids to settle\n            if self.currentBid == 0.0 {\n                self.retToOwner()\n                self.auctionCompleted = true\n                \n                emit Settled(auctionID: self.auctionID)\n                return\n            }            \n\n\n            // Send the market and artist share first\n            let amountMarket = self.currentBid * self.parameters.marketCut\n            let amountArtist = self.currentBid * self.parameters.artistCut\n            let marketCut <- self.escrow.withdraw(amount:amountMarket)\n            let artistCut <- self.escrow.withdraw(amount:amountArtist)\n\n            let marketVault = BaguetteAuction.marketVault!.borrow() ?? panic(\"The market vault link is broken.\")\n            marketVault.deposit(from: <- marketCut)\n            emit MarketplaceEarned(auctionID: self.auctionID, amount: amountMarket, owner: marketVault.owner!.address)\n            \n            let artistID = self.item?.metadata!.artistID\n            ArtistRegistery.sendArtistShare(id: artistID, deposit: <-artistCut)\n            emit ArtistEarned(auctionID: self.auctionID, amount: amountArtist, artistID: artistID)\n            \n            // Send the FUSD to the seller and the NFT to the highest bidder\n            self.sendNFT(self.bidderRCollection!)\n            self.sendBidTokens(self.ownerFVault)\n\n            self.auctionCompleted = true\n            \n            emit Settled(auctionID: self.auctionID)\n        }\n\n        // Place a new bid\n        pub fun placeBid(\n            bidTokens: @FungibleToken.Vault, \n            fVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>, \n            rCollection: Capability<&Record.Collection{Record.CollectionPublic}>) {\n            pre {\n                !self.auctionCompleted: \"auction has already completed\"\n                bidTokens.balance >= self.minNextBid(): \"bid amount be larger or equal to the current price + minimum bid increment\"\n                fVault.check(): \"The fungible vault should be valid.\"\n                rCollection.check(): \"The non fungible collection should be valid.\"\n            }\n            \n            if self.escrow.balance != 0.0 {\n                // bidderFVault should not be nil as something has been placed in escrow\n                self.sendBidTokens(self.bidderFVault!)\n            }\n\n            // Update the auction item\n            self.escrow.deposit(from: <-bidTokens) // will fail if it is not a @FUSD.Vault\n\n            // extend time if in last X seconds\n            if self.timeRemaining() < Fix64(self.parameters.timeExtension) {\n                self.extendWith(self.parameters.timeExtension)\n            }\n\n            // Add the bidder's Vault and NFT receiver references\n            self.bidderAddr = rCollection.address\n            self.bidderFVault = fVault\n            self.bidderRCollection = rCollection    \n\n            // Update the current price of the token\n            self.currentBid = self.escrow.balance\n            self.numberOfBids = self.numberOfBids + (1 as UInt64)\n\n            let status = self.getAuctionStatus()\n            emit NewBid(auctionID: self.auctionID, status: status)\n        }\n\n        // Get the auction status\n        // Will fail if the auction is completed (item is nil). \n        // A completed auction should be deleted anyway as it is worthless\n        pub fun getAuctionStatus(): AuctionStatus {\n            return AuctionStatus(\n                id: self.auctionID,\n                recordID: self.item?.id!,\n                metadata: self.item?.metadata!,\n                owner: self.ownerAddr,\n                leader: self.bidderAddr,\n                currentBid: self.currentBid, \n                nextMinBid: self.minNextBid(),\n                numberOfBids: self.numberOfBids,\n                bidIncrement: self.parameters.bidIncrement,\n                startTime: Fix64(self.auctionStartTime),\n                endTime: Fix64(self.auctionEndTime),\n                timeExtension: self.parameters.timeExtension,\n                expired: self.isAuctionExpired()\n            )\n        }\n\n        destroy() {\n            // send the NFT back to auction owner\n            if self.item != nil {\n                self.sendNFT(self.ownerRCollection)\n            }\n            \n            // if there's a bidder...\n            if let vaultCap = self.bidderFVault {\n                // ...send the bid tokens back to the bidder\n                self.sendBidTokens(vaultCap)\n            }\n\n            destroy self.item\n            destroy self.escrow\n        }\n    }\n\n    // CollectionPublic\n    //\n    // Public methods of an AuctionCollection, allowing to settle an auction and retrieve information\n    //\n    pub resource interface CollectionPublic {\n        pub let collectionID: UInt64\n        pub let parameters: AuctionParameters\n\n        pub fun getIDs(): [UInt64]\n        pub fun getAuctionStatus(_ recordID:UInt64): AuctionStatus\n\n        // the settle functions are public since they just transfer NFT/tokens when the auction is done\n        pub fun settleAuction(_ recordID: UInt64)\n    }\n\n    // Bidder\n    //\n    // Public methods of an Collection, allowing to place bids\n    //\n    pub resource interface Bidder {\n        pub let collectionID: UInt64\n        pub let parameters: AuctionParameters\n\n        pub fun placeBid(\n            recordID: UInt64, \n            bidTokens: @FungibleToken.Vault, \n            fVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>, \n            rCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        )\n    }\n\n    // AuctionCreator\n    //\n    // Interface giving access to the createAuction function\n    //\n    pub resource interface AuctionCreator {\n        pub let collectionID: UInt64\n        pub let parameters: AuctionParameters\n\n        pub fun createAuction(\n            record: @Record.NFT, \n            startPrice: UFix64,\n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            ownerRCollection: Capability<&Record.Collection{Record.CollectionPublic}>) \n    }\n\n    // Collection\n    //\n    // Collection representing a set of auctions and their parameters\n    //\n    pub resource Collection: CollectionPublic, AuctionCreator, Bidder {\n\n        pub let collectionID: UInt64\n        pub let parameters: AuctionParameters\n        \n        // Auction Items, where the key is the recordID\n        access(self) var auctionItems: @{UInt64: Auction}\n\n        init(parameters: AuctionParameters) {\n            self.auctionItems <- {}\n            self.parameters = parameters \n\n            BaguetteAuction.totalCollections = BaguetteAuction.totalCollections + (1 as UInt64)\n            self.collectionID = BaguetteAuction.totalCollections\n        }\n\n        // Create an auction with the parameters given at the collection initialization\n        pub fun createAuction(\n            record: @Record.NFT, \n            startPrice: UFix64,\n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            ownerRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            let id = record.id\n\n            let auction <- create Auction(\n                item: <-record,\n                parameters: self.parameters, \n                auctionStartTime: getCurrentBlock().timestamp + self.parameters.auctionDelay,\n                startPrice: startPrice,\n                ownerFVault: ownerFVault,\n                ownerRCollection: ownerRCollection\n            )\n            let status = auction.getAuctionStatus()\n            self.auctionItems[id] <-! auction\n            \n            emit Created(auctionID: status.id, admin: self.owner?.address!, status: status)\n        }\n\n        // getIDs returns an array of the IDs that are in the collection\n        pub fun getIDs(): [UInt64] {\n            return self.auctionItems.keys\n        }\n\n        pub fun getAuctionStatus(_ recordID:UInt64): AuctionStatus {\n            pre {\n                self.auctionItems[recordID] != nil:\n                    \"NFT doesn't exist\"\n            }\n\n            // Get the auction item resources\n            return self.auctionItems[recordID]?.getAuctionStatus()!\n        }\n\n        // settleAuction sends the auction item to the highest bidder\n        // and deposits the FungibleTokens into the auction owner's account\n        // destroys the auction if it has already been settled\n        pub fun settleAuction(_ recordID: UInt64) { \n            let auctionRef = &self.auctionItems[recordID] as &Auction\n            if(auctionRef.isAuctionExpired()) {\n                auctionRef.settleAuction()\n                if(!auctionRef.isAuctionCompleted()) {\n                    panic(\"Auction was not settled properly\")\n                }\n\n                destroy self.auctionItems.remove(key: recordID)!\n            }\n        }\n\n\n        // placeBid sends the bidder's tokens to the bid vault and updates the\n        // currentPrice of the current auction item\n        pub fun placeBid(\n            recordID: UInt64, \n            bidTokens: @FungibleToken.Vault, \n            fVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>, \n            rCollection: Capability<&Record.Collection{Record.CollectionPublic}>) {\n            pre {\n                self.auctionItems[recordID] != nil:\n                    \"Auction does not exist in this drop\"\n            }\n\n            // Get the auction item resources\n            let itemRef = &self.auctionItems[recordID] as &Auction\n            itemRef.placeBid(\n                bidTokens: <-bidTokens, \n                fVault: fVault, \n                rCollection: rCollection\n            )\n        }\n\n        destroy() {\n            destroy self.auctionItems\n        }\n    }\n\n    // An auction collection creator can create auction collections with default parameters\n    pub resource interface CollectionCreator {\n        pub fun createAuctionCollection(): @Collection\n    }\n    \n    // Admin can change the default Auction parameters, the market vault and create custom collections\n    pub resource Admin: CollectionCreator {\n        \n        pub fun setParameters(parameters: AuctionParameters) {\n            BaguetteAuction.parameters = parameters\n        }\n\n        pub fun setMarketVault(marketVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            pre {\n                marketVault.check(): \"The market vault should be valid.\"\n            }\n            BaguetteAuction.marketVault = marketVault\n        }\n\n        pub fun setLostAndFoundVaults(\n            fVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            rCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            pre {\n                fVault.check(): \"The fungible token vault should be valid.\"\n                rCollection.check(): \"The NFT collection should be valid.\"\n            }\n            BaguetteAuction.lostFVault = fVault\n            BaguetteAuction.lostRCollection = rCollection\n        }\n\n        // create collection with default parameters\n        pub fun createAuctionCollection(): @Collection {\n            return <- create Collection(parameters: BaguetteAuction.parameters)\n        }\n\n        // create collection with custom parameters\n        pub fun createCustomAuctionCollection(parameters: AuctionParameters): @Collection {\n            return <- create Collection(parameters: parameters)\n        }\n    }\n\n    // This interface is used to add a Admin capability to a client\n    pub resource interface ManagerClient {\n        pub fun addCapability(_ cap: Capability<&Admin{CollectionCreator}>)\n    }\n\n    // An Manager can create an auction collection with the default parameters\n    pub resource Manager: ManagerClient, CollectionCreator {\n\n        access(self) var server: Capability<&Admin{CollectionCreator}>?\n\n        init() {\n            self.server = nil\n        }\n\n         pub fun addCapability(_ cap: Capability<&Admin{CollectionCreator}>) {\n            pre {\n                cap.check() : \"Invalid server capablity\"\n                self.server == nil : \"Server already set\"\n            }\n            self.server = cap\n        }\n\n        pub fun createAuctionCollection(): @Collection {\n            pre {\n                self.server != nil: \n                    \"Cannot create AuctionCollection if server is not set\"\n            }\n            \n            return <- self.server!.borrow()!.createAuctionCollection()\n        }\n    }\n    \n    // -----------------------------------------------------------------------\n    // Contract public functions\n    // -----------------------------------------------------------------------\n\n    // make it possible to delegate auction collection creation (with default parameters)\n    pub fun createManager(): @Manager {\n        return <- create Manager()\n    }\n    \n    \n    // -----------------------------------------------------------------------\n    // Initialization function\n    // -----------------------------------------------------------------------\n\n    init() {\n        self.totalAuctions = 0\n        self.totalCollections = 0\n\n        self.parameters = AuctionParameters(\n            artistCut: 0.10,\n            marketCut: 0.03,\n            bidIncrement: 1.0,\n            auctionLength: 259200.0, // 3 days\n            auctionDelay: 0.0,\n            timeExtension: 600.0 // 10 minutes\n        )\n        \n        self.marketVault = nil\n        self.lostFVault = nil\n        self.lostRCollection = nil\n\n        self.CollectionPublicPath = /public/boulangeriev1AuctionCollection\n        self.CollectionPrivatePath = /private/boulangeriev1AuctionCollection\n        self.CollectionStoragePath = /storage/boulangeriev1AuctionCollection\n        self.ManagerPublicPath = /public/boulangeriev1AuctionManager\n        self.ManagerStoragePath = /storage/boulangeriev1AuctionManager\n        self.AdminStoragePath = /storage/boulangeriev1AuctionAdmin\n        self.AdminPrivatePath = /private/boulangeriev1AuctionAdmin\n\n        self.account.save(<- create Admin(), to: self.AdminStoragePath)\n        self.account.link<&Admin{CollectionCreator}>(self.AdminPrivatePath, target: self.AdminStoragePath)\n    }\n\n}\n "},{"address":"0x3558f4548a40dc77","contractName":"BaguetteOffer","code":"/** \n\n# BaguetteOffer contract\n\nThis contract defines the offer system of Baguette. \nThe offer contract acts as an escrow for fungible tokens which can be exchange when presented the corresponding Record.\nOffers are centralized in OfferCollection maintained by admins.  \n\n## Withdrawals and cancelations\n\nOffers can be cancelled by the offeror.\n\n## Create an offer\nAn Offer is created within an OfferCollection. An OfferCollection can be created in two ways:\n- by the contract Admin, who can choose the offer parameters. \n- by an Manager who has been initialized by an Admin. The different parameters are fixed at creation by the Admin to the contract parameters at that time.\n\n## Accepting an offer\n\nA seller can present an NFT with a corresponding offer and has two solutions to accept it:\n- direct sale\n- accept the offer as a first bid of an auction\n*/\n\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Record from 0x3558f4548a40dc77\nimport ArtistRegistery from 0x3558f4548a40dc77\nimport BaguetteAuction from 0x3558f4548a40dc77\n\npub contract BaguetteOffer {\n\n    // -----------------------------------------------------------------------\n    // Variables \n    // -----------------------------------------------------------------------\n\n    // Resource paths\n    // Public path of an offer collection, allowing the place new offers and to access to public information\n    pub let CollectionPublicPath: PublicPath\n    // Storage path of an offer collection\n    pub let CollectionStoragePath: StoragePath\n    // Manager public path, allowing an Admin to initialize it\n    pub let ManagerPublicPath: PublicPath\n    // Manager storage path, for a manager to create offer collections\n    pub let ManagerStoragePath: StoragePath\n    // Offeror storage path\n    pub let OfferorStoragePath: StoragePath\n    // Admin storage path\n    pub let AdminStoragePath: StoragePath\n    // Admin private path, allowing initialized AuctionManager to create collections while hidding other admin functions\n    pub let AdminPrivatePath: PrivatePath\n\n    // Default parameters for offers\n    pub var parameters: OfferParameters\n    access(self) var marketVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n    access(self) var lostFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n    access(self) var lostRCollection: Capability<&Record.Collection{Record.CollectionPublic}>?\n\n    // total number of offers ever created\n    pub var totalOffers: UInt64\n\n    // -----------------------------------------------------------------------\n    // Events \n    // -----------------------------------------------------------------------\n\n    // A new offer has been made\n    pub event NewOffer(offerID: UInt64, admin: Address, status: OfferStatus)\n    // The offer had been canceled\n    pub event OfferCanceled(offerID: UInt64)\n    // The offer has been accepted directly\n    pub event AcceptedDirectly(offerID: UInt64)\n    // The offer has been accepted as first bid\n    pub event AcceptedAsBid(offerID: UInt64)\n    \n    // Market and Artist share\n    pub event MarketplaceEarned(offerID: UInt64, amount: UFix64, owner: Address)\n    pub event ArtistEarned(offerID: UInt64, amount: UFix64, artistID: UInt64)\n\n    // lost and found events\n    pub event FUSDLostAndFound(offerID: UInt64, amount: UFix64, address: Address)\n    pub event RecordLostAndFound(offerID: UInt64, recordID: UInt64, address: Address)\n\n    // -----------------------------------------------------------------------\n    // Resources \n    // -----------------------------------------------------------------------\n\n    // Structure representing offer parameters\n    pub struct OfferParameters {\n        pub let artistCut: UFix64 // share of the artist for a sale\n        pub let marketCut: UFix64 // share of the marketplace for a sale\n        pub let offerIncrement: UFix64 // minimal increment between offers\n        pub let timeBeforeCancel: UFix64 // minimal amount of time before an offer can be canceled\n\n        init(\n            artistCut: UFix64,\n            marketCut: UFix64,\n            offerIncrement: UFix64,\n            timeBeforeCancel: UFix64\n        ) {\n            self.artistCut = artistCut\n            self.marketCut = marketCut\n            self.offerIncrement = offerIncrement\n            self.timeBeforeCancel = timeBeforeCancel\n        }\n    }\n\n    // This structure holds the main information about an offer\n    pub struct OfferStatus {\n        pub let id: UInt64\n        pub let recordID: UInt64\n        pub let offeror: Address\n        pub let offer: UFix64\n        pub let nextMinOffer: UFix64\n        pub let offerIncrement: UFix64\n    \n        init(\n            id: UInt64,\n            recordID: UInt64,\n            offeror: Address, \n            offer: UFix64,\n            nextMinOffer: UFix64,\n            offerIncrement: UFix64\n        ) {\n            self.id = id\n            self.recordID = recordID\n            self.offeror = offeror\n            self.offer = offer \n            self.nextMinOffer = nextMinOffer\n            self.offerIncrement = offerIncrement\n        }\n    }\n\n    // Resource representing a unique Offer\n    pub resource Offer {\n        pub let creationTime: UFix64\n        pub let offerID: UInt64\n        pub let recordID: UInt64\n        pub let parameters: OfferParameters\n\n        priv let offer: UFix64\n        priv let offeror: Address\n        priv let escrow: @FUSD.Vault \n        priv var isValid: Bool\n\n        //the capabilities pointing to the resource where you want the NFT\n        priv var offerorFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>\n        priv var offerorRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n\n        init(\n            parameters: OfferParameters,\n            recordID: UInt64,\n            offerTokens: @FungibleToken.Vault,\n            offerorFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            offerorRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            pre {\n                offerorFVault.check(): \"The fungible vault should be valid.\"\n                offerorRCollection.check(): \"The non fungible collection should be valid.\"\n            }\n\n            self.creationTime = getCurrentBlock().timestamp\n\n            BaguetteOffer.totalOffers = BaguetteOffer.totalOffers + (1 as UInt64)\n            self.offerID = BaguetteOffer.totalOffers\n\n            self.parameters = parameters\n            self.recordID = recordID\n\n            self.escrow <- offerTokens as! @FUSD.Vault\n            self.offer = self.escrow.balance\n            self.offeror = offerorFVault.address\n            self.offerorFVault = offerorFVault\n            self.offerorRCollection = offerorRCollection\n\n            self.isValid = true\n        }\n\n        // sendNFT sends the NFT to the Collection belonging to the provided Capability or to the lost and found if the capability is broken\n        // if both the receiver collection and lost and found are unlinked, the record is destroyed\n        access(self) fun sendNFT(record: @Record.NFT, rCollection: Capability<&Record.Collection{Record.CollectionPublic}>) {\n            if let collectionRef = rCollection.borrow() {\n                collectionRef.deposit(token: <-record)\n                return\n            } \n\n            if let collectionRef = BaguetteOffer.lostRCollection!.borrow() {\n                let recordID = record.id\n                collectionRef.deposit(token: <-record)\n                \n                emit RecordLostAndFound(offerID: self.offerID, recordID: recordID, address: collectionRef.owner!.address)\n                return \n            }\n            \n            // should never happen in practice\n            destroy record\n        }\n\n        // sendOfferTokens sends the bid tokens to the Vault Receiver belonging to the provided Capability\n        access(self) fun sendOfferTokens(_ capability: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            if let vaultRef = capability.borrow() {\n                if self.escrow.balance > 0.0 { \n                    vaultRef.deposit(from: <-self.escrow.withdraw(amount: self.escrow.balance))\n                }\n                return\n            }\n            else if let vaultRef = BaguetteOffer.lostFVault!.borrow() {\n                let balance = self.escrow.balance\n                if balance > 0.0 { \n                    vaultRef.deposit(from: <-self.escrow.withdraw(amount: balance))\n                    emit FUSDLostAndFound(offerID: self.offerID, amount: balance, address: vaultRef.owner!.address)\n                }\n                return\n            }\n        }\n\n        // Send the previous bid back to the last bidder\n        access(contract) fun cancelOffer() {\n            pre {\n                self.isValid: \"Offer is not valid.\"\n            }\n\n            self.isValid = false\n            self.sendOfferTokens(self.offerorFVault) \n        }\n\n        // Accept the offer directly\n        access(contract) fun acceptOffer(\n            record: @Record.NFT,\n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>\n        ) {\n            pre {\n                record.tradable(): \"The item cannot be traded due to its current locked mode: it is probably waiting for its decryption key.\"\n                self.isValid: \"Offer is not valid.\"\n            }\n\n            let amountMarket = self.offer * self.parameters.marketCut\n            let amountArtist = self.offer * self.parameters.artistCut\n            let marketCut <- self.escrow.withdraw(amount:amountMarket)\n            let artistCut <- self.escrow.withdraw(amount:amountArtist)\n\n            let marketVault = BaguetteOffer.marketVault!.borrow() ?? panic(\"The market vault link is broken.\")\n            marketVault.deposit(from: <- marketCut)\n            emit MarketplaceEarned(offerID: self.offerID, amount: amountMarket, owner: marketVault.owner!.address)\n\n            let artistID = record.metadata.artistID\n            ArtistRegistery.sendArtistShare(id: artistID, deposit: <-artistCut)\n            emit ArtistEarned(offerID: self.offerID, amount: amountArtist, artistID: artistID)\n\n            self.sendOfferTokens(ownerFVault)\n            self.sendNFT(record: <-record, rCollection: self.offerorRCollection)\n            self.isValid = false \n\n            emit AcceptedDirectly(offerID: self.offerID)\n        }\n\n        // create an auction with the offer as first bid\n        // if the offeror vault and collections are not valid anymore, it could block the function\n        // instead, the tokens are sent to LostAndFound, and the NFT returned to the owner,\n        // to deter bad behavior\n        access(contract) fun acceptAuctionOffer(\n            auctionCollection: &BaguetteAuction.Collection{BaguetteAuction.Bidder, BaguetteAuction.AuctionCreator},\n            record: @Record.NFT,\n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            ownerRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            pre {\n                record.tradable(): \"The item cannot be traded due to its current locked mode: it is probably waiting for its decryption key.\"\n                self.isValid: \"Offer is not valid.\"\n            }\n\n            if(!self.offerorFVault.check() || !self.offerorRCollection.check()) {\n                self.sendOfferTokens(BaguetteOffer.lostFVault!)\n                self.sendNFT(record: <-record, rCollection: ownerRCollection)\n                self.isValid = false\n\n                return\n            }\n\n            let recordID = record.id\n            auctionCollection.createAuction(\n                record: <-record, \n                startPrice: self.offer,\n                ownerFVault: ownerFVault,\n                ownerRCollection: ownerRCollection\n            ) \n\n            auctionCollection.placeBid(\n                recordID: recordID, \n                bidTokens: <-self.escrow.withdraw(amount: self.offer), \n                fVault: self.offerorFVault, \n                rCollection: self.offerorRCollection\n            )\n            self.isValid = false \n\n            emit AcceptedAsBid(offerID: self.offerID)\n        }\n\n        // What the next offer has to match\n        pub fun minNextOffer(): UFix64{\n            return self.offer + self.parameters.offerIncrement\n        }\n\n        // Get the auction status\n        // Will fail is offer is not valid\n        // It is worthless and should be destroyed\n        pub fun getOfferStatus(): OfferStatus {\n            pre {\n                self.isValid: \"Offer is not valid.\"\n            }\n\n            return OfferStatus(\n                id: self.offerID,\n                recordID: self.recordID,\n                offeror: self.offeror,\n                offer: self.offer,\n                nextMinOffer: self.minNextOffer(),\n                offerIncrement: self.parameters.offerIncrement\n            )\n        }\n\n        destroy() {\n            // if the offer is still valid, it should be canceled\n            if self.isValid {\n                self.cancelOffer()\n            }\n\n            destroy self.escrow\n        }\n    }\n\n    // CollectionPublic\n    //\n    // Public methods of an OfferCollection, getting status of offers\n    //\n    pub resource interface CollectionPublic {\n        pub let parameters: OfferParameters\n\n        pub fun getIDs(): [UInt64]\n        pub fun getOfferStatus(_ recordID:UInt64): OfferStatus\n    }\n\n    // Seller\n    //\n    // Interface exposing functions to accept an offer\n    //\n    pub resource interface Seller {\n        pub let parameters: OfferParameters\n\n        pub fun acceptDirectOffer(record: @Record.NFT, ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>)\n        pub fun acceptAuctionOffer(\n            record: @Record.NFT, \n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            ownerRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        )\n    }\n\n    // Offeror\n    //\n    // Interface exposing function to post or cancel an offer\n    //\n    pub resource interface Offeror {\n        access(contract) fun addOffer(\n            recordID: UInt64, \n            offerTokens: @FungibleToken.Vault,\n            offerorFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            offerorRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        )\n        access(contract) fun cancelOffer(recordID: UInt64, offerID: UInt64)\n    }\n\n    // AuctionCreatorClient\n    //\n    // Allows to receive an auctionCreator capability to create auctions when accepting offers\n    //\n    pub resource interface AuctionCreatorClient {\n        pub fun addCapability(_ cap: Capability<&BaguetteAuction.Collection{BaguetteAuction.Bidder, BaguetteAuction.AuctionCreator}>)\n    }\n\n    // Collection\n    //\n    // Collection allowing to create new auctions\n    //\n    pub resource Collection: CollectionPublic, Seller, Offeror, AuctionCreatorClient {\n\n        pub let parameters: OfferParameters\n        access(self) var auctionServer: Capability<&BaguetteAuction.Collection{BaguetteAuction.Bidder, BaguetteAuction.AuctionCreator}>?\n        access(self) var auctionServerAccepted: UInt64?\n        \n        // Auction Items, where the key is the recordID\n        access(self) var offerItems: @{UInt64: Offer}\n\n        init(parameters: OfferParameters) {\n            self.offerItems <- {}\n            self.parameters = parameters \n\n            self.auctionServer = nil\n            self.auctionServerAccepted = nil\n        }\n\n        pub fun setAuctionServerAccepted(serverID: UInt64) {\n            self.auctionServerAccepted = serverID\n        }\n\n        // getIDs returns an array of the IDs that are in the collection\n        pub fun getIDs(): [UInt64] {\n            return self.offerItems.keys\n        }\n\n        pub fun getOfferStatus(_ recordID:UInt64): OfferStatus {\n            pre {\n                self.offerItems[recordID] != nil:\n                    \"NFT doesn't exist\"\n            }\n\n            // Get the auction item resources\n            return self.offerItems[recordID]?.getOfferStatus()!\n        }\n\n        pub fun acceptDirectOffer(record: @Record.NFT, ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            pre {\n                self.offerItems[record.id] != nil:\n                    \"NFT doesn't exist\"\n            }\n            let recordID = record.id \n            let itemRef = &self.offerItems[recordID] as &Offer\n            itemRef.acceptOffer(record: <-record, ownerFVault: ownerFVault)\n\n            destroy self.offerItems.remove(key: recordID)!\n        }\n\n        pub fun acceptAuctionOffer(\n            record: @Record.NFT, \n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            ownerRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            pre {\n                self.offerItems[record.id] != nil:\n                    \"NFT doesn't exist\"\n                self.auctionServer != nil : \"Auction server not set\"\n                self.auctionServer!.check() : \"Auction server link broken\"\n            }\n            let recordID = record.id \n            let itemRef = &self.offerItems[recordID] as &Offer\n            itemRef.acceptAuctionOffer(\n                auctionCollection: self.auctionServer!.borrow()!,\n                record: <-record, \n                ownerFVault: ownerFVault,\n                ownerRCollection: ownerRCollection\n            )\n\n            destroy self.offerItems.remove(key: recordID)!\n        }\n\n        access(contract) fun addOffer(\n            recordID: UInt64, \n            offerTokens: @FungibleToken.Vault,\n            offerorFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            offerorRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            // check if there is an existing offer\n            if(self.offerItems[recordID] != nil) {\n                let itemRef = &self.offerItems[recordID] as &Offer\n                if(itemRef.getOfferStatus().nextMinOffer > offerTokens.balance) {\n                    panic(\"The offer is not high enough\")\n                }\n                let id = itemRef.offerID\n                itemRef.cancelOffer()\n                destroy self.offerItems.remove(key: recordID)!\n                emit OfferCanceled(offerID: id)\n            } \n\n            let offer <- create Offer(\n                parameters: self.parameters,\n                recordID: recordID,\n                offerTokens: <-offerTokens,\n                offerorFVault: offerorFVault,\n                offerorRCollection: offerorRCollection\n            )\n            let offerStatus = offer.getOfferStatus()\n            let old <- self.offerItems[recordID] <- offer\n            destroy old\n\n            emit NewOffer(offerID: offerStatus.id, admin: self.owner?.address!, status: offerStatus)\n        }\n\n        access(contract) fun cancelOffer(recordID: UInt64, offerID: UInt64) {\n            pre {\n                self.offerItems[recordID] != nil: \"No offer for this item.\" \n            }\n            let itemRef = &self.offerItems[recordID] as &Offer\n            if(itemRef.offerID != offerID) {\n                panic(\"The ID of the offer does not match the current offer on this item.\")\n            }\n            if(itemRef.creationTime + self.parameters.timeBeforeCancel > getCurrentBlock().timestamp) {\n                panic(\"The offer cannot be canceled yet.\")\n            }\n            let id = itemRef.offerID\n            itemRef.cancelOffer()\n\n            destroy self.offerItems.remove(key: recordID)!\n\n            emit OfferCanceled(offerID: id)\n        }\n\n        pub fun addCapability(_ cap: Capability<&BaguetteAuction.Collection{BaguetteAuction.Bidder, BaguetteAuction.AuctionCreator}>) {\n            pre {\n                cap.check() : \"Invalid server capablity\"\n                self.auctionServer == nil : \"Server already set\"\n                self.auctionServerAccepted != nil: \"No auction server can be accepted yet\"\n                cap.borrow()!.collectionID == self.auctionServerAccepted!: \"This is not the correct auction server\"\n            }\n            self.auctionServer = cap\n        }\n        \n        destroy() {\n            destroy self.offerItems\n        }\n    }\n\n    // CollectionCreator\n    //\n    // An auction collection creator can create offer collection with default parameters\n    //\n    pub resource interface CollectionCreator {\n        pub fun createOfferCollection(): @Collection\n    }\n    \n    // Admin\n    //\n    // Admin can change the default Offer parameters, the market vault and create custom collections\n    //\n    pub resource Admin: CollectionCreator {\n        \n        pub fun setParameters(parameters: OfferParameters) {\n            BaguetteOffer.parameters = parameters\n        }\n\n        pub fun setMarketVault(marketVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            pre {\n                marketVault.check(): \"The market vault should be valid.\"\n            }\n            BaguetteOffer.marketVault = marketVault\n        }\n\n        pub fun setLostAndFoundVaults(\n            fVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            rCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            pre {\n                fVault.check(): \"The fungible token vault should be valid.\"\n                rCollection.check(): \"The NFT collection should be valid.\"\n            }\n            BaguetteOffer.lostFVault = fVault\n            BaguetteOffer.lostRCollection = rCollection\n        }\n\n        // create collection with default parameters\n        pub fun createOfferCollection(): @Collection {\n            return <- create Collection(parameters: BaguetteOffer.parameters)\n        }\n\n        // create collection with custom parameters\n        pub fun createCustomOfferCollection(parameters: OfferParameters): @Collection {\n            return <- create Collection(parameters: parameters)\n        }\n    }\n\n    // ManagerClient\n    //\n    // This interface is used to add a Admin capability to a client\n    //\n    pub resource interface ManagerClient {\n        pub fun addCapability(_ cap: Capability<&Admin{CollectionCreator}>)\n    }\n\n    // Manager\n    //\n    // An Manager can create OfferCollection with the default parameters\n    //\n    pub resource Manager: ManagerClient, CollectionCreator {\n\n        access(self) var server: Capability<&Admin{CollectionCreator}>?\n\n        init() {\n            self.server = nil\n        }\n\n        pub fun addCapability(_ cap: Capability<&Admin{CollectionCreator}>) {\n            pre {\n                cap.check() : \"Invalid server capablity\"\n                self.server == nil : \"Server already set\"\n            }\n            self.server = cap\n        }\n\n        pub fun createOfferCollection(): @Collection {\n            pre {\n                self.server != nil: \n                    \"Cannot create OfferCollection if server is not set\"\n            }\n            \n            return <- self.server!.borrow()!.createOfferCollection()\n        }\n    }\n\n    // OfferorCollection\n    //\n    // Lists all the offers of a buyer and give them the possibility to cancel offers\n    //\n    pub resource OfferorCollection {\n\n        priv let offers: {UInt64: UInt64} // recordID -> offerID\n        init() {\n            self.offers = {}\n        }\n\n        pub fun addOffer(\n            offerCollection: &Collection{Offeror},\n            recordID: UInt64, \n            offerTokens: @FungibleToken.Vault,\n            offerorFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>,\n            offerorRCollection: Capability<&Record.Collection{Record.CollectionPublic}>\n        ) {\n            offerCollection.addOffer(\n                recordID: recordID,\n                offerTokens: <-offerTokens,\n                offerorFVault: offerorFVault,\n                offerorRCollection: offerorRCollection\n            )\n\n            self.offers[recordID] = BaguetteOffer.totalOffers\n        }\n\n        pub fun cancelOffer(\n            offerCollection: &Collection{Offeror},\n            recordID: UInt64\n        ) {\n            pre {\n                self.offers[recordID] != nil: \"There is no offer for this item.\"\n            }\n\n            offerCollection.cancelOffer(recordID: recordID, offerID: self.offers[recordID]!)\n            self.offers.remove(key: recordID)\n        }\n\n        pub fun hasOffer(recordID: UInt64): Bool {\n            return false\n        }\n    }\n    \n    // -----------------------------------------------------------------------\n    // Contract public functions\n    // -----------------------------------------------------------------------\n\n    // \n    pub fun createManager(): @Manager {\n        return <- create Manager()\n    }\n\n    // \n    pub fun createOfferor(): @OfferorCollection {\n        return <- create OfferorCollection()\n    }\n    \n    \n    // -----------------------------------------------------------------------\n    // Initialization function\n    // -----------------------------------------------------------------------\n\n    init() {\n        self.totalOffers = 0\n\n        self.parameters = OfferParameters(\n            artistCut: 0.10,\n            marketCut: 0.03,\n            offerIncrement: 1.0,\n            timeBeforeCancel: 86400.0\n        )\n        \n        self.marketVault = nil\n        self.lostFVault = nil\n        self.lostRCollection = nil\n\n        self.CollectionPublicPath = /public/boulangeriev1OfferCollection\n        self.CollectionStoragePath = /storage/boulangeriev1OfferCollection\n        self.ManagerPublicPath = /public/boulangeriev1OfferManager\n        self.ManagerStoragePath = /storage/boulangeriev1OfferManager\n        self.OfferorStoragePath = /storage/boulangeriev1OfferOfferor\n        self.AdminStoragePath = /storage/boulangeriev1OfferAdmin\n        self.AdminPrivatePath = /private/boulangeriev1OfferAdmin\n\n        self.account.save(<- create Admin(), to: self.AdminStoragePath)\n        self.account.link<&Admin{CollectionCreator}>(self.AdminPrivatePath, target: self.AdminStoragePath)\n    }\n\n}\n "},{"address":"0x3558f4548a40dc77","contractName":"BaguetteSale","code":"/** \n\n# BaguetteSale contract\n\nThis contract allows to create SaleCollection to put a record for direct sale. \nThe collection has a capability to withdraw from the record collection of the seller, without getting access to record unlocking functions.\n\n## Withdrawals and cancelations\n\nListings can be cancelled. \n\n## Accept an offer\n\nOffers are settled automatically since it is a directl listing.\n\n## Create a Sale\nA Sale is created within a SaleCollection. A SaleCollection is kept in a user's storage and points to their record collection.\nA SaleCollection is created through a contract level function which the default market and artist cuts set by an admin.\n\n*/\n\n\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport Record from 0x3558f4548a40dc77\nimport ArtistRegistery from 0x3558f4548a40dc77\n\n\npub contract BaguetteSale {\n\n    // -----------------------------------------------------------------------\n    // Variables \n    // -----------------------------------------------------------------------\n\n    // Public path to the sale collection, allowing to buy listed items\n    pub let CollectionPublicPath: PublicPath\n    // Storage path to the sale collection\n    pub let CollectionStoragePath: StoragePath\n    // Admin storage page, allowing sale collection creation and parameter changes\n    pub let AdminStoragePath: StoragePath\n\n    // Default parameters for auctions\n    pub var parameters: SaleParameters\n    access(self) var marketVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n    access(self) var lostFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>?\n\n    // -----------------------------------------------------------------------\n    // Events \n    // -----------------------------------------------------------------------\n\n    // Events direct offers\n    //\n    // A record has been purchased via direct sale\n    pub event RecordPurchased(recordID: UInt64, price: UFix64, seller: Address)\n    // A record has been listed for direct sale\n    pub event ListingCreated(recordID: UInt64, price: UFix64, seller: Address)\n    // A listing has been canceled\n    pub event ListingCanceled(recordID: UInt64, seller: Address)\n\n    // Market and Artist share\n    pub event MarketplaceEarned(recordID: UInt64, seller: Address, amount: UFix64, owner: Address)\n    pub event ArtistEarned(recordID: UInt64, seller: Address, amount: UFix64, artistID: UInt64)\n\n    // lost and found events\n    pub event FUSDLostAndFound(recordID: UInt64, seller: Address, amount: UFix64, address: Address)\n\n    // -----------------------------------------------------------------------\n    // Resources \n    // -----------------------------------------------------------------------\n\n    // Structure representing auction parameters\n    pub struct SaleParameters {\n        pub let artistCut: UFix64 // share of the artist for a sale\n        pub let marketCut: UFix64 // share of the marketplace for a sale\n\n        init(\n            artistCut: UFix64,\n            marketCut: UFix64\n        ) {\n            self.artistCut = artistCut\n            self.marketCut = marketCut\n        }\n    }\n    \n    // CollectionPublic\n    //\n    // Expose information retrieval functions and buyer interface\n    //\n    pub resource interface CollectionPublic {\n        pub var parameters: SaleParameters\n\n        pub fun purchase(tokenID: UInt64, buyTokens: @FUSD.Vault): @Record.NFT {\n            post {\n                result.id == tokenID: \"The ID of the withdrawn token must be the same as the requested ID\"\n            }\n        }\n        pub fun getPrice(tokenID: UInt64): UFix64?\n        pub fun getIDs(): [UInt64]\n        pub fun isForSale(tokenID: UInt64): Bool \n    }\n\n    pub resource Collection: CollectionPublic {\n\n        pub var parameters: SaleParameters\n\n        access(self) var ownerCollection: Capability<&Record.Collection{Record.CollectionPublic, NonFungibleToken.Provider}>\n        access(self) var ownerCapability: Capability<&FUSD.Vault{FungibleToken.Receiver}>\n\n        access(self) var prices: {UInt64: UFix64}\n        \n\n        init (\n            parameters: SaleParameters, \n            fVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>, \n            rCollection: Capability<&Record.Collection{Record.CollectionPublic, NonFungibleToken.Provider}>) {\n            pre {\n                fVault.check(): \"The fungible vault should be valid.\"\n                rCollection.check(): \"The non fungible collection should be valid.\"\n            }\n            self.prices = {}\n            self.ownerCapability = fVault\n            self.ownerCollection = rCollection\n            \n            self.parameters = parameters\n        }\n\n        // List the item for sale. Note that there is no check here to see if the item is tradable (unlocked without decryption key)\n        // However, the during a sale, the transaction of the trade will panic if the item is not tradable\n        pub fun listForSale(tokenID: UInt64, price: UFix64) {\n            pre {\n                self.ownerCollection.borrow()!.borrowRecord(recordID: tokenID) != nil:\n                    \"Record does not exist in the owner's collection\"\n                self.ownerCollection.borrow()!.borrowRecord(recordID: tokenID)!.tradable(): \"The item cannot be traded due to its current locked mode: it is probably waiting for its decryption key.\"\n            }\n\n            // Set the token's price\n            self.prices[tokenID] = price\n\n            emit ListingCreated(recordID: tokenID, price: price, seller: self.owner?.address!)\n        }\n\n        pub fun cancelSale(tokenID: UInt64) {\n            pre {\n                self.prices[tokenID] != nil: \"Token with the specified ID is not already for sale\"\n            }\n\n            // Remove the price from the prices dictionary\n            self.prices.remove(key: tokenID)\n\n            // Set prices to nil for the withdrawn ID\n            self.prices[tokenID] = nil\n            \n            // Emit the event for withdrawing a moment from the Sale\n            emit ListingCanceled(recordID: tokenID, seller: self.owner?.address!)\n        }\n\n        pub fun purchase(tokenID: UInt64, buyTokens: @FUSD.Vault): @Record.NFT {\n            pre {\n                self.ownerCollection.borrow()!.borrowRecord(recordID: tokenID) != nil && self.prices[tokenID] != nil:\n                    \"No token matching this ID for sale!\"           \n                self.ownerCollection.borrow()!.borrowRecord(recordID: tokenID)!.tradable(): \"The item cannot be traded due to its current locked mode: it is probably waiting for its decryption key.\"\n                buyTokens.balance == (self.prices[tokenID] ?? 0.0):\n                    \"Not enough tokens to buy the NFT!\"\n            }\n\n            let price = self.prices[tokenID]!\n            self.prices[tokenID] = nil\n\n            let record <- self.ownerCollection.borrow()!.withdraw(withdrawID: tokenID) as! @Record.NFT\n\n            // Deposit it into the beneficiary's Vault\n            let amountMarket = price * self.parameters.marketCut\n            let amountArtist = price * self.parameters.artistCut\n            let marketCut <- buyTokens.withdraw(amount:amountMarket)\n            let artistCut <- buyTokens.withdraw(amount:amountArtist)\n\n            let marketVault = BaguetteSale.marketVault!.borrow()!\n            marketVault.deposit(from: <- marketCut)\n            emit MarketplaceEarned(recordID: record.id, seller: self.owner?.address!, amount: amountMarket, owner: marketVault.owner!.address)\n\n            let artistID = record.metadata.artistID\n            ArtistRegistery.sendArtistShare(id: artistID, deposit: <-artistCut)\n            emit ArtistEarned(recordID: record.id, seller: self.owner?.address!, amount: amountArtist, artistID: artistID)\n\n            // Deposit the remaining tokens into the owners vault\n            // If the owner capability is unlinked, tries the lost and found. If it is unlinked too (should not happen in practice), tokens are destroyed\n            var fVaultOpt = self.ownerCapability.borrow()\n            if fVaultOpt == nil {\n                fVaultOpt = BaguetteSale.lostFVault!.borrow()\n                if fVaultOpt != nil {\n                    emit FUSDLostAndFound(recordID: tokenID, seller: self.owner?.address!, amount: buyTokens.balance, address: fVaultOpt!.owner!.address)\n                }\n            }\n\n            if let fVault = fVaultOpt {\n                fVault.deposit(from: <-buyTokens.withdraw(amount: buyTokens.balance))\n            }\n            destroy buyTokens\n\n            emit RecordPurchased(recordID: tokenID, price: price, seller: self.owner?.address!)\n            return <-record\n        }\n\n        pub fun getPrice(tokenID: UInt64): UFix64? {\n            return self.prices[tokenID]\n        }\n\n        pub fun getIDs(): [UInt64] {\n            return self.prices.keys\n        }\n\n        // Check if the sale is still available\n        pub fun isForSale(tokenID: UInt64): Bool {\n            return self.ownerCollection.borrow()!.borrowRecord(recordID: tokenID) != nil \n                && self.prices[tokenID] != nil\n                && self.ownerCollection.borrow()!.borrowRecord(recordID: tokenID)!.tradable()\n        }\n    }\n\n    // Admin resource\n    //\n    // Admin can change the market & artist cuts and market vault. \n    // The administrator can create SaleCollection with custom parameters.\n    //\n    pub resource Admin {\n        \n        pub fun setParameters(parameters: SaleParameters) {\n            BaguetteSale.parameters = parameters\n        }\n\n        // Set the vault used to collect market shares\n        pub fun setMarketVault(marketVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>) {\n            pre {\n                marketVault.check(): \"The market vault should be valid.\"\n            }\n            BaguetteSale.marketVault = marketVault\n        }\n\n        pub fun setLostAndFoundVaults(\n            fVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>\n        ) {\n            pre {\n                fVault.check(): \"The fungible token vault should be valid.\"\n            }\n            BaguetteSale.lostFVault = fVault\n        }\n\n        // createCollection returns a new collection resource to the caller\n        pub fun createCustomSaleCollection(\n            parameters: SaleParameters, \n            ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>, \n            ownerNFVault: Capability<&Record.Collection{Record.CollectionPublic, NonFungibleToken.Provider}>): @Collection {\n            \n            return <- create Collection(\n                parameters: parameters,\n                fVault: ownerFVault,\n                rCollection: ownerNFVault\n            )\n        }\n    }\n\n    // -----------------------------------------------------------------------\n    // Contract public functions\n    // -----------------------------------------------------------------------\n\n    // createCollection returns a new collection resource to the caller, with default market & artist shares\n    pub fun createSaleCollection(\n        ownerFVault: Capability<&FUSD.Vault{FungibleToken.Receiver}>, \n        ownerNFVault: Capability<&Record.Collection{Record.CollectionPublic, NonFungibleToken.Provider}>): @Collection {\n        \n        return <- create Collection(\n            parameters: BaguetteSale.parameters,\n            fVault: ownerFVault,\n            rCollection: ownerNFVault\n        )\n    }\n\n    // -----------------------------------------------------------------------\n    // Initialization function\n    // -----------------------------------------------------------------------\n\n    init() {\n        self.parameters = SaleParameters(\n            artistCut: 0.10,\n            marketCut: 0.03\n        )\n        self.marketVault = nil\n        self.lostFVault = nil\n\n        self.CollectionPublicPath = /public/boulangeriev1SaleCollection\n        self.CollectionStoragePath = /storage/boulangeriev1SaleCollection\n        self.AdminStoragePath = /storage/boulangeriev1SaleAdmin\n\n        self.account.save(<- create Admin(), to: self.AdminStoragePath)\n    }\n}\n "},{"address":"0x3558f4548a40dc77","contractName":"NameTag","code":"\n// Simplified version from https://flow-view-source.com/testnet/account/0xba1132bc08f82fe2/contract/Profile\n// It allows to somone to update a stauts on the blockchain\n\npub contract NameTag {\n  pub let publicPath: PublicPath\n  pub let storagePath: StoragePath\n\n  pub resource interface Public {\n    pub fun readTag(): String\n  }\n  \n  pub resource interface Owner {\n    pub fun readTag(): String\n    \n    pub fun changeTag(_ tag: String) {\n      pre {\n        tag.length <= 15:\n          \"Tags must be under 15 characters long.\"\n      }\n    }\n  }\n  \n  pub resource Base: Owner, Public {\n    access(self) var tag: String\n    \n    init() {\n      self.tag = \"\"\n    }\n    \n    pub fun readTag(): String { return self.tag }\n    pub fun changeTag(_ tag: String) { self.tag = tag }\n  }\n  \n  pub fun new(): @NameTag.Base {\n    return <- create Base()\n  }\n  \n  pub fun hasTag(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&{NameTag.Public}>(NameTag.publicPath)\n      .check()\n  }\n  \n  pub fun fetch(_ address: Address): &{NameTag.Public} {\n    return getAccount(address)\n      .getCapability<&{NameTag.Public}>(NameTag.publicPath)\n      .borrow()!\n  }\n    \n  init() {\n    self.publicPath = /public/boulangeriev1PublicNameTag\n    self.storagePath = /storage/boulangeriev1StorageNameTag\n    \n    self.account.save(<- self.new(), to: self.storagePath)\n    self.account.link<&Base{Public}>(self.publicPath, target: self.storagePath)\n  }\n}"},{"address":"0x3558f4548a40dc77","contractName":"Record","code":"/**  \n# Contract defining records and songs. \n\n## Record:\nA record is the unique issuance of a song. \nIt holds the information including song title, artist, description, cover image address (an IPFS CID) and audio address (IPFS CID). \n\nSongs are by default hidden, meaning the audio file is encrypted. The holder can decide to reveal the song (publish the decryption key). \nPublishing the decryption key is done by an admin when the resource is made accessible in \"unlocked\" mode. \nOnce the decryption key has been set, it cannot be changed again.\n\nA record unlocked but without an decryption key should be prevented from being set for auction or for sale. \nIt represents the case when the song has been unlock but the admin is still uploading the encryption key. \nWe do not want buyers to bid on a song they think is still unreleased, and then discover is was being released. \nIf the owner wants to cancel the publication of the key before it has been done, they can call the `lock` function.\n\nA record points to an artist, defined by an ID. An artist registery is held so that the artist share can be sent correctly after sales and auctions.\n**/\n\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport ArtistRegistery from 0x3558f4548a40dc77\n\npub contract Record: NonFungibleToken {\n\n    // -----------------------------------------------------------------------\n    // Variables \n    // -----------------------------------------------------------------------\n\n    // Access paths\n    //\n    // Public path allowing deposits, listing of IDs and access to records metadata\n    pub let CollectionPublicPath: PublicPath\n\n    // Private path allowing withdrawals on top of the public access\n    // Useful for SaleCollection requiring withdrawals, but protecting lock/unlock functions\n    pub let CollectionPrivatePath: PrivatePath\n    // Storage path of the collection of records owned\n    pub let CollectionStoragePath: StoragePath\n    // Storage path of the Admin, responsible for uploading decryption keys\n    pub let AdminStoragePath: StoragePath\n    // Storage path of the miner responsible for creating new records\n    pub let MinterStoragePath: StoragePath\n    // The total number of Record NFTs that have been created\n    pub var totalSupply: UInt64\n\n    // -----------------------------------------------------------------------\n    // Events\n    // -----------------------------------------------------------------------\n\n    // Emitted when the contract is created\n    pub event ContractInitialized()\n\n    // Emitted when a new record is minted\n    pub event RecordMinted(id: UInt64, metadata: Metadata)\n    // Emited when a record is deleted \n    pub event RecordDestroyed(id: UInt64)\n    // Emited when a record is locked \n    pub event RecordLocked(id: UInt64)\n    // Emited when a record is unlocked \n    pub event RecordUnlocked(id: UInt64)\n    // Emitted when a record audio key is published\n    pub event RecordKeyUploaded(id: UInt64, audiokey: String)\n    // Emitted when a record is withdrawn from a Collection\n    pub event Withdraw(id: UInt64, from: Address?)\n    // Emitted when a record is deposited into a Collection\n    pub event Deposit(id: UInt64, to: Address?)\n\n    // -----------------------------------------------------------------------\n    // Resources\n    // -----------------------------------------------------------------------\n    \n    // Structure representing the metadata of a record\n    pub struct Metadata {\n        pub let title: String // title of the record\n        pub let artistID: UInt64 // this ID can be used in the ArtistRegistery contract functions\n        pub let description: String // description an artist can write about the record\n        pub let audioaddr: String // record audio address (IPFS CID)\n        pub let coveraddr: String // cover image address (IPFS CID)\n\n        init(  \n            title: String, \n            artistID: UInt64,\n            description: String, \n            audioaddr: String, \n            coveraddr: String\n        ) {\n            self.title = title\n            self.artistID = artistID\n            self.description = description\n            self.audioaddr = audioaddr\n            self.coveraddr = coveraddr\n        }\n    }\n\n    // Interface for records when accessed publicly\n    pub resource interface Public {\n        pub let id: UInt64\n        pub let metadata: Metadata\n        pub var audiokey: String?\n\n        // Whether the record decryption key is locked\n        pub fun isLocked(): Bool \n        // Whether the record decryption key is unlocked but unset yet\n        pub fun tradable(): Bool\n\n        // this function can only be called by the admin, and will fail if the record is still locked\n        access(contract) fun setAudioKey(audiokey: String) \n    }\n\n    // Resource representing a unique song. Can only be created by a minter\n    pub resource NFT: NonFungibleToken.INFT, Public {\n\n        // Unique ID for the record\n        pub let id: UInt64\n\n        pub let metadata: Metadata\n        pub var audiokey: String? // key used to decrypt the audio content\n        pub var locked: Bool\n\n        init(metadata: Metadata) {\n            pre {\n                metadata.artistID <= ArtistRegistery.numberOfArtists: \"This artistID does not exist\"\n            }\n            \n            Record.totalSupply = Record.totalSupply + (1 as UInt64)\n            self.id = Record.totalSupply\n\n            self.metadata = metadata\n            self.audiokey = nil\n            self.locked = true\n\n            emit RecordMinted(id: self.id, metadata: self.metadata)\n        }\n\n        // attach the url to a newly released song, when is unlocked\n        access(contract) fun setAudioKey(audiokey: String) {\n          pre {\n            self.audiokey == nil: \"The key has already been set.\"\n            !self.locked: \"This record is locked\"\n          }\n\n          self.audiokey = audiokey \n          emit RecordKeyUploaded(id: self.id, audiokey: audiokey)\n        }\n\n        access(contract) fun lock() {\n            self.locked = true\n            emit RecordLocked(id: self.id)\n        }\n\n        access(contract) fun unlock() {\n            self.locked = false\n            emit RecordUnlocked(id: self.id)\n        }\n\n        pub fun isLocked(): Bool {\n            return self.locked\n        }\n\n        pub fun tradable(): Bool {\n            return self.locked || self.audiokey != nil\n        }\n\n        destroy() {\n            emit RecordDestroyed(id: self.id)\n        }\n    }\n\n    // Admin resource\n    //\n    // Can create new admins and set decryption keys of unlocked songs\n    pub resource Admin {\n\n        // Publish the decryption key of the record `id` from the given collection\n        pub fun setRecordAudioKey(collection: &Collection{CollectionPublic}, id: UInt64, audiokey: String) {\n            collection.borrowRecord(recordID: id)!.setAudioKey(audiokey: audiokey)\n        }\n\n        // New admins can be created by an admin.\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n        // New minters can be created by an admin.\n        pub fun createNewMinter(): @Minter {\n            return <-create Minter()\n        }\n    }\n\n    // Minter resource\n    //\n    // A minter is responsible for minting new records\n    pub resource Minter {\n\n        // Mint a new record with the given information\n        pub fun mintRecord(\n            title: String, \n            artistID: UInt64,\n            description: String, \n            audioaddr: String, \n            coveraddr: String\n            ): @Record.NFT {\n            \n            let record <- create NFT(\n                metadata: Metadata(\n                    title: title, \n                    artistID: artistID,\n                    description: description, \n                    audioaddr: audioaddr, \n                    coveraddr: coveraddr\n                )\n            )\n\n            return <-record\n        }\n    }\n\n    // Public interface for a record collection. \n    // It allows someone to check what is inside someone's collection or to deposit a record in it.\n    pub resource interface CollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowRecord(recordID: UInt64): &{Record.Public}? {\n            post {\n                (result == nil) || (result?.id == recordID): \n                    \"Cannot borrow Record reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // A collection of one's records\n    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic { \n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        // Withdraw a given record from the collection\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\n            // Remove the nft from the Collection\n            let record <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Record does not exist in the collection\")\n\n            emit Withdraw(id: record.id, from: self.owner?.address)\n            \n            return <-record\n        }\n\n        // Deposit a record\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            \n            // Cast the deposited record as a Record NFT to make sure\n            // it is the correct type\n            let token <- token as! @Record.NFT\n\n            let id = token.id\n            let oldRecord <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            destroy oldRecord\n        }\n\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // Get and NFT as a NonFungibleToken.NFT reference\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return &self.ownedNFTs[id] as &NonFungibleToken.NFT\n        }\n\n        // Get and NFT as a Record.Public reference\n        pub fun borrowRecord(recordID: UInt64): &{Record.Public}? {\n            if self.ownedNFTs[recordID] != nil {\n                let ref = &self.ownedNFTs[recordID] as auth &NonFungibleToken.NFT\n                return ref as! &Record.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // Lock the requested record \n        pub fun lockRecord(recordID: UInt64) {\n            pre {\n                self.ownedNFTs[recordID] != nil: \"The requested record cannot be found in the collection\"\n            }\n\n            if self.ownedNFTs[recordID] != nil {\n                let refNFT = &self.ownedNFTs[recordID] as auth &NonFungibleToken.NFT\n                let refRecord = refNFT as! &Record.NFT\n                refRecord.lock()\n            }\n        }\n\n        // Unlock the requested record \n        pub fun unlockRecord(recordID: UInt64) {\n            pre {\n                self.ownedNFTs[recordID] != nil: \"The requested record cannot be found in the collection\"\n            }\n\n            if self.ownedNFTs[recordID] != nil {\n                let refNFT = &self.ownedNFTs[recordID] as auth &NonFungibleToken.NFT\n                let refRecord = refNFT as! &Record.NFT\n                refRecord.unlock()\n            }\n        }\n\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }\n\n    // -----------------------------------------------------------------------\n    // Contract public functions\n    // -----------------------------------------------------------------------\n\n    // Create a collection to hold records\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <-create Record.Collection()\n    }\n\n    // -----------------------------------------------------------------------\n    // Initialization function\n    // -----------------------------------------------------------------------\n    \n    init() {\n        self.CollectionPublicPath = /public/boulangeriev1RecordCollection\n        self.CollectionPrivatePath = /private/boulangeriev1RecordCollection\n        self.CollectionStoragePath = /storage/boulangeriev1RecordCollection\n        self.AdminStoragePath = /storage/boulangeriev1RecordAdminStorage\n        self.MinterStoragePath = /storage/boulangeriev1RecordMinterStorage\n        \n        self.totalSupply = 0\n\n        self.account.save<@Collection>(<- create Collection(), to: self.CollectionStoragePath)\n\n        self.account.link<&Collection{CollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)\n        self.account.link<&Collection{Record.CollectionPublic, NonFungibleToken.Provider}>(self.CollectionPrivatePath, target: self.CollectionStoragePath)\n\n        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)\n        self.account.save<@Minter>(<- create Minter(), to: self.MinterStoragePath)\n\n        emit ContractInitialized()\n    }\n}\n"}]